<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=yes">
  <meta name="description" content="How to use graphs">
  <title>Grafos - Pesquisa</title>
</head>

<body>

<h1 style="text-align: center;">Grafos - Pesquisa</h1>
<center><span style="font-size: small;"><em>João Pedro Neto</em></span></center>

<p>Uma das tarefas mais básicas sobre <a class="autolink" title="Grafos" href="https://moodle.ciencias.ulisboa.pt/mod/page/view.php?id=113913">grafos</a> é como atravessar todos os seus vértices. Como nas árvores existem várias alternativas para atravessar um grafo.</p>
<p>Esta página é sobre a <strong>pesquisa em profundidade</strong> (em inglês, <strong>depth-first search, dfs</strong>) e <strong>pesquisa em largura</strong> (<strong>breadth-first search, bfs</strong>).</p>
<p></p>
<h4><strong>Depth-first Search</strong></h4>
<p>A ideia é simples: escolhe-se um vértice (a raiz) e avança-se por um caminho qualquer. Há medida que se visitam os vértices temos de o indicar numa estrutura auxiliar (para evitar entrarmos em ciclos infinitos). Quando chegamos a um beco sem saída (todos os vértices vizinhos foram já visitados) volta-se para trás via <a href="https://en.wikipedia.org/wiki/Backtracking"><em>backtracking</em></a> e continua-se num caminho ainda com nós por visitar. Quando voltamos à raiz e todos os seus vizinhos foram visitados, a travessia terminou.</p>
<p>A imagem seguinte mostra os vários caminhos percorridos no dfs, onde cada <em>backtracking</em> é indicado pela mudança da cor:</p>
<p style="text-align: center;"><img src="imgs/graph_dfs.png" width="384" height="353" /></p>
<p style="text-align: left;">O mecanismo de <em>backtracking</em> pode ser efectuado usando uma Stack: armazena-se na pilha os vizinhos do vértice actual e segue-se caminho. Quando chegados a um beco sem saída, tira-se o elemento do topo da pilha e continua-se (se a pilha estiver vazia, a travessia terminou).</p>
<p style="text-align: left;">A complexidade do dfs é O(V+E), sendo V o número de vértices e E o número de arestas (<em>edges</em>).</p>
<p style="text-align: left;">O método que executa o dfs na classe GraphMatrix:</p>
<pre style="background-color: #ffffff; color: #000000; font-family: 'Courier New'; margin-left: 30px;"><span style="font-size: small;"><span style="color: #808080; font-style: italic;">/**<br /></span><span style="color: #808080; font-style: italic;"> * Depth-first search from a given node<br /></span><span style="color: #808080; font-style: italic;"> * </span><span style="color: #808080; font-weight: bold; font-style: italic;">@param </span><span style="color: #3d3d3d; font-weight: bold; font-style: italic;">node </span><span style="color: #808080; font-style: italic;">The node from which to start<br /></span><span style="color: #808080; font-style: italic;"> * </span><span style="color: #808080; font-weight: bold; font-style: italic;">@complexity </span><span style="color: #808080; font-style: italic;">O(V </span>+ <span style="color: #808080; font-style: italic;">E)<br /></span><span style="color: #808080; font-style: italic;"> * </span><span style="color: #808080; font-weight: bold; font-style: italic;">@requires </span><span style="color: #808080; font-style: italic;">a directed graph<br /></span><span style="color: #808080; font-style: italic;"> * </span><span style="color: #808080; font-weight: bold; font-style: italic;">@return </span><span style="color: #808080; font-style: italic;">an array with the indexes of the dfs<br /></span><span style="color: #808080; font-style: italic;"> */<br /></span><span style="color: #000080; font-weight: bold;">public int</span>[] dfs(<span style="color: #000080; font-weight: bold;">int </span>node) {</span><br /><span style="font-size: small;">   Stack&lt;Integer&gt; stack = <span style="color: #000080; font-weight: bold;">new </span>Stack&lt;Integer&gt;();      <span style="color: #808080; font-style: italic;">// for backtracking<br /></span><span style="color: #808080; font-style: italic;">   </span>ArrayList&lt;Integer&gt; l = <span style="color: #000080; font-weight: bold;">new </span>ArrayList&lt;Integer&gt;();  <span style="color: #808080; font-style: italic;">// contains the visiting order<br /></span><span style="color: #808080; font-style: italic;">   </span><span style="color: #000080; font-weight: bold;">boolean</span>[] visited    = <span style="color: #000080; font-weight: bold;">new boolean</span>[<span style="color: #660e7a; font-weight: bold;">size</span>];         <span style="color: #808080; font-style: italic;">// false means not visited<br /></span><span style="color: #808080; font-style: italic;"><br /></span><span style="color: #808080; font-style: italic;">   </span>stack.push(node);</span><br /><br /><span style="font-size: small;">   <span style="color: #000080; font-weight: bold;">while</span>(!stack.isEmpty()) {</span><br /><span style="font-size: small;">      <span style="color: #000080; font-weight: bold;">int </span>current = stack.pop();</span><br /><span style="font-size: small;">      <span style="color: #000080; font-weight: bold;">if </span>(visited[current])</span><br /><span style="font-size: small;">         <span style="color: #000080; font-weight: bold;">continue</span>;</span><br /><span style="font-size: small;">      visited[current] = <span style="color: #000080; font-weight: bold;">true</span>;</span><br /><span style="font-size: small;">      l.add(current);</span><br /><span style="font-size: small;">      <span style="color: #000080; font-weight: bold;">for</span>(<span style="color: #000080; font-weight: bold;">int </span>next : sucessors(current))</span><br /><span style="font-size: small;">         <span style="color: #000080; font-weight: bold;">if </span>(!visited[next])</span><br /><span style="font-size: small;">             stack.push(next);</span><br /><span style="font-size: small;">   }</span><br /><br /><span style="font-size: small;">   <span style="color: #000080; font-weight: bold;">return </span>list2array(l);</span><br /><span style="font-size: small;">}</span></pre>
<p style="text-align: left;">Um problema que utiliza o dfs na solução é o <a href="https://uva.onlinejudge.org/external/119/11902.pdf">UVa 11902</a>. Veremos que o dfs está subjacente a muitos outros algoritmos sobre <a class="autolink" title="Grafos" href="https://moodle.ciencias.ulisboa.pt/mod/page/view.php?id=113913">grafos</a>, tornando-o um algoritmo muito importante para se perceber bem e saber usar.</p>
<p style="text-align: left;"></p>
<h4 style="text-align: left;"><strong>Breadth-first Search</strong></h4>
<p style="text-align: left;">A pesquisa em largura, bfs, é muito semelhante ao dfs. A principal diferença é que os vértices 'irmãos' são percorridos antes do vértices 'filhos'.</p>
<p style="text-align: left;">Esta imagem mostra a diferença em termos visuais:</p>
<p style="text-align: center;"><img src="imgs/graph_dfs_vs_bfs.gif" width="544" height="268" /></p>
<p style="text-align: left;"></p>
<p style="text-align: left;">A forma de implementar o bfs é utilizar uma fila de espera (<em>queue</em>) em vez de uma pilha. Desta forma implementamos um sistema FIFO que permite que os vértices vizinhos da raiz sejam visitados em primeiro lugar.</p>
<pre style="background-color: #ffffff; color: #000000; font-family: 'Courier New'; margin-left: 30px;"><span style="font-size: small;"><span style="color: #808080; font-style: italic;">/**<br /></span><span style="color: #808080; font-style: italic;"> * Breath-first search from a given node<br /></span><span style="color: #808080; font-style: italic;"> * </span><span style="color: #808080; font-weight: bold; font-style: italic;">@param </span><span style="color: #3d3d3d; font-weight: bold; font-style: italic;">node </span><span style="color: #808080; font-style: italic;">The node from which to start<br /></span><span style="color: #808080; font-style: italic;"> * </span><span style="color: #808080; font-weight: bold; font-style: italic;">@complexity </span><span style="color: #808080; font-style: italic;">O(V </span>+ <span style="color: #808080; font-style: italic;">E)<br /></span><span style="color: #808080; font-style: italic;"> * </span><span style="color: #808080; font-weight: bold; font-style: italic;">@requires </span><span style="color: #808080; font-style: italic;">a directed graph<br /></span><span style="color: #808080; font-style: italic;"> * </span><span style="color: #808080; font-weight: bold; font-style: italic;">@return </span><span style="color: #808080; font-style: italic;">an array with the indexes of the bfs<br /></span><span style="color: #808080; font-style: italic;"> */<br /></span><span style="color: #000080; font-weight: bold;">public int</span>[] bfs(<span style="color: #000080; font-weight: bold;">int </span>node) {</span><br /><span style="font-size: small;">   Queue&lt;Integer&gt; queue = <span style="color: #000080; font-weight: bold;">new </span>LinkedList&lt;Integer&gt;();</span><br /><span style="font-size: small;">   ArrayList&lt;Integer&gt; l = <span style="color: #000080; font-weight: bold;">new </span>ArrayList&lt;Integer&gt;();</span><br /><span style="font-size: small;">   <span style="color: #000080; font-weight: bold;">boolean</span>[] visited    = <span style="color: #000080; font-weight: bold;">new boolean</span>[<span style="color: #660e7a; font-weight: bold;">size</span>];</span><br /><br /><span style="font-size: small;">   queue.add(node);</span><br /><br /><span style="font-size: small;">   <span style="color: #000080; font-weight: bold;">while</span>(!queue.isEmpty()) {</span><br /><span style="font-size: small;">      <span style="color: #000080; font-weight: bold;">int </span>current = queue.poll();</span><br /><span style="font-size: small;">      <span style="color: #000080; font-weight: bold;">if </span>(visited[current])</span><br /><span style="font-size: small;">         <span style="color: #000080; font-weight: bold;">continue</span>;</span><br /><span style="font-size: small;">      visited[current] = <span style="color: #000080; font-weight: bold;">true</span>;</span><br /><span style="font-size: small;">      l.add(current);</span><br /><span style="font-size: small;">      <span style="color: #000080; font-weight: bold;">for</span>(<span style="color: #000080; font-weight: bold;">int </span>next : sucessors(current))</span><br /><span style="font-size: small;">         <span style="color: #000080; font-weight: bold;">if </span>(!visited[next])</span><br /><span style="font-size: small;">            queue.add(next);</span><br /><span style="font-size: small;">   }</span><br /><br /><span style="font-size: small;">   <span style="color: #000080; font-weight: bold;">return </span>list2array(l);</span><br /><span style="font-size: small;">}</span></pre>
<p style="text-align: left;">Esta é uma <a href="https://uva.onlinejudge.org/index.php?option=onlinejudge&amp;Itemid=99999999&amp;category=148">lista de problemas</a> onde o bfs pode ser usado.</p>

<div class="modified">Last modified: Wednesday, 21 June 2017, 9:40 AM</div>

</body>
</html>