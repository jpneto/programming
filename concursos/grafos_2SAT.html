<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=yes">
  <meta name="description" content="How to use graphs">
  <title>2-SAT</title>
</head>

<body>

<h1 style="text-align: center;">O Problema 2-SAT</h1>
<center><span style="font-size: small;"><em>João Pedro Neto</em></span></center>

<p>Vamos considerar o problema de ter que satisfazer uma fórmula 2-CNF, ie, uma conjunção de disjunções de duas variáveis booleanas (ou as suas negações).</p>
<p>Um exemplo: (x1 ∨ x2) ∧ (¬x1 ∨ ¬x2)</p>
<p>Será que é possível satisfazer este exemplo? Sim, se x1 = true e x2 = false.</p>
<p>Outro exemplo: (x1 ∨ x2) ∧ (¬x1 ∨ x2) ∧ (¬x2 ∨ x3) ∧ (¬x2 ∨¬x3)</p>
<p>Neste caso não é possível satisfazer o problema. Poderíamos calcular as oito linhas da tabela de verdade para verificar este facto.</p>
<p>Chama-se a este problema 2-SAT porque pretendemos satisfazer cláusulas com duas variáveis.</p>
<p>O problema mais geral (onde uma disjunção pode ter n variáveis) chama-se SAT e é NP-completo, sendo problemas que não se conhecem soluções de complexidade polinomial, apenas exponencial.</p>
<p>No entanto, o problema 2-SAT é de complexidade polinomial e pode ser resolvido mais rapidamente.</p>
<p>O primeiro passo é perceber que uma fórmula 2-CNF pode ser traduzida para um grafo!</p>
<p>Como? Ora sabemos que (a ∨ b) ≡ (¬a ⇒ b) ≡ (¬b ⇒ a) e estas implicações vão tornar-se arestas orientadas entre os nós das variáveis (ou das suas negações).</p>
<p style="text-align: left;">Vejamos o primeiro exemplo:  (x1 ∨ x2) ∧ (¬x1 ∨ ¬x2)</p>
<p style="text-align: center;">  (x1 ∨ x2) ≡ (¬x1 ⇒ x2) ≡ (¬x2 ⇒ x1)</p>
<p style="text-align: center;">  (¬x1 ∨ ¬x2) ≡ (x1 ⇒ ¬x2) ≡ (x2 ⇒ ¬x1)</p>
<p style="text-align: left;">o que produz o grafo:</p>
<p style="text-align: center;"><img src="imgs/2sat-1.jpg" width="204" height="187" /></p>
<p style="text-align: left;">Já o segundo exemplo (x1 ∨ x2) ∧ (¬x1 ∨ x2) ∧ (¬x2 ∨ x3) ∧ (¬x2 ∨¬x3) produz o grafo (confiram)</p>
<p style="text-align: center;"><img src="imgs/2sat-2.jpg" width="216" height="261" /></p>
<p style="text-align: left;">E agora vem a propriedade que justifica este mapear:</p>
<p style="text-align: center;">uma fórmula 2-CNF é satisfazível se e só se <em>nenhuma variável pertence ao mesmo SCC (strong connected component) que a sua negação</em>.</p>
<p style="text-align: left;">Na primeira fórmula há duas SCC's, {0,3} e {1,2} e em nenhuma das quais recai uma variável e a sua negação. Já na segunda fórmula só há uma SCC onde estão todos os nós e isso inclui, por exemplo, x1 e ¬x1, o que torna a fórmula não satisfazível.</p>
<p style="text-align: left;">Poder-se-ia usar o método de cálculo das SCC da classe dada Graph. Ter-se-ia ainda de verificar se as variáveis e as suas negações estariam nas mesmas componentes ou não.</p>
<p style="text-align: left;">A solução seguinte não usa estes métodos e é auto-contida (menos código para digitar).</p>
<pre style="background-color: #ffffff; color: #000000; font-family: 'Courier New'; margin-left: 30px;"><span style="font-size: small;"><span style="color: #000080; font-weight: bold;">import </span>java.util.*;</span><br /><span style="font-size: small;"><span style="color: #000080; font-weight: bold;">import </span>java.util.stream.Stream;</span><br /><br /><span style="font-size: small;"><span style="color: #000080; font-weight: bold;">public class </span>SAT2 {</span><br /><br /><span style="font-size: small;">    <span style="color: #000080; font-weight: bold;">static void </span>dfs1(List&lt;Integer&gt;[] graph, <span style="color: #000080; font-weight: bold;">boolean</span>[] used, List&lt;Integer&gt; order, <span style="color: #000080; font-weight: bold;">int </span>u) {</span><br /><span style="font-size: small;">        used[u] = <span style="color: #000080; font-weight: bold;">true</span>;</span><br /><span style="font-size: small;">        <span style="color: #000080; font-weight: bold;">for </span>(<span style="color: #000080; font-weight: bold;">int </span>v : graph[u])</span><br /><span style="font-size: small;">            <span style="color: #000080; font-weight: bold;">if </span>(!used[v])</span><br /><span style="font-size: small;">                <span style="font-style: italic;">dfs1</span>(graph, used, order, v);</span><br /><span style="font-size: small;">        order.add(u);</span><br /><span style="font-size: small;">    }</span><br /><br /><span style="font-size: small;">    <span style="color: #000080; font-weight: bold;">static void </span>dfs2(List&lt;Integer&gt;[] reverseGraph, <span style="color: #000080; font-weight: bold;">int</span>[] comp, <span style="color: #000080; font-weight: bold;">int </span>u, <span style="color: #000080; font-weight: bold;">int </span>color) {</span><br /><span style="font-size: small;">        comp[u] = color;</span><br /><span style="font-size: small;">        <span style="color: #000080; font-weight: bold;">for </span>(<span style="color: #000080; font-weight: bold;">int </span>v : reverseGraph[u])</span><br /><span style="font-size: small;">            <span style="color: #000080; font-weight: bold;">if </span>(comp[v] == -<span style="color: #0000ff;">1</span>)</span><br /><span style="font-size: small;">                <span style="font-style: italic;">dfs2</span>(reverseGraph, comp, v, color);</span><br /><span style="font-size: small;">    }</span><br /><br /><span style="font-size: small;">    <span style="color: #000080; font-weight: bold;">public static boolean</span>[] solve2Sat(List&lt;Integer&gt;[] graph) {</span><br /><span style="font-size: small;">        <span style="color: #000080; font-weight: bold;">int </span>n = graph.<span style="color: #660e7a; font-weight: bold;">length</span>;</span><br /><span style="font-size: small;">        <span style="color: #000080; font-weight: bold;">boolean</span>[] used = <span style="color: #000080; font-weight: bold;">new boolean</span>[n];</span><br /><span style="font-size: small;">        List&lt;Integer&gt; order = <span style="color: #000080; font-weight: bold;">new </span>ArrayList&lt;&gt;();</span><br /><span style="font-size: small;">        <span style="color: #000080; font-weight: bold;">for </span>(<span style="color: #000080; font-weight: bold;">int </span>i = <span style="color: #0000ff;">0</span>; i &lt; n; ++i)</span><br /><span style="font-size: small;">            <span style="color: #000080; font-weight: bold;">if </span>(!used[i])</span><br /><span style="font-size: small;">                <span style="font-style: italic;">dfs1</span>(graph, used, order, i);</span><br /><br /><span style="font-size: small;">        List&lt;Integer&gt;[] reverseGraph = Stream.<span style="font-style: italic;">generate</span>(ArrayList::<span style="color: #000080; font-weight: bold;">new</span>).limit(n).toArray(List[]::<span style="color: #000080; font-weight: bold;">new</span>);</span><br /><span style="font-size: small;">        <span style="color: #000080; font-weight: bold;">for </span>(<span style="color: #000080; font-weight: bold;">int </span>i = <span style="color: #0000ff;">0</span>; i &lt; n; i++)</span><br /><span style="font-size: small;">            <span style="color: #000080; font-weight: bold;">for </span>(<span style="color: #000080; font-weight: bold;">int </span>j : graph[i])</span><br /><span style="font-size: small;">                reverseGraph[j].add(i);</span><br /><br /><span style="font-size: small;">        <span style="color: #000080; font-weight: bold;">int</span>[] comp = <span style="color: #000080; font-weight: bold;">new int</span>[n];</span><br /><span style="font-size: small;">        Arrays.<span style="font-style: italic;">fill</span>(comp, -<span style="color: #0000ff;">1</span>);</span><br /><span style="font-size: small;">        <span style="color: #000080; font-weight: bold;">for </span>(<span style="color: #000080; font-weight: bold;">int </span>i = <span style="color: #0000ff;">0</span>, color = <span style="color: #0000ff;">0</span>; i &lt; n; ++i) {</span><br /><span style="font-size: small;">            <span style="color: #000080; font-weight: bold;">int </span>u = order.get(n - i - <span style="color: #0000ff;">1</span>);</span><br /><span style="font-size: small;">            <span style="color: #000080; font-weight: bold;">if </span>(comp[u] == -<span style="color: #0000ff;">1</span>)</span><br /><span style="font-size: small;">                <span style="font-style: italic;">dfs2</span>(reverseGraph, comp, u, color++);</span><br /><span style="font-size: small;">        }</span><br /><br /><span style="font-size: small;">        <span style="color: #000080; font-weight: bold;">for </span>(<span style="color: #000080; font-weight: bold;">int </span>i = <span style="color: #0000ff;">0</span>; i &lt; n; ++i)</span><br /><span style="font-size: small;">            <span style="color: #000080; font-weight: bold;">if </span>(comp[i] == comp[i ^ <span style="color: #0000ff;">1</span>])</span><br /><span style="font-size: small;">                <span style="color: #000080; font-weight: bold;">return null</span>;</span><br /><br /><span style="font-size: small;">        <span style="color: #000080; font-weight: bold;">boolean</span>[] res = <span style="color: #000080; font-weight: bold;">new boolean</span>[n / <span style="color: #0000ff;">2</span>];</span><br /><span style="font-size: small;">        <span style="color: #000080; font-weight: bold;">for </span>(<span style="color: #000080; font-weight: bold;">int </span>i = <span style="color: #0000ff;">0</span>; i &lt; n; i += <span style="color: #0000ff;">2</span>)</span><br /><span style="font-size: small;">            res[i / <span style="color: #0000ff;">2</span>] = comp[i] &gt; comp[i ^ <span style="color: #0000ff;">1</span>];</span><br /><span style="font-size: small;">        <span style="color: #000080; font-weight: bold;">return </span>res;</span><br /><span style="font-size: small;">    }</span></pre>
<p style="text-align: left;">O seguinte main() testa este código para a fórmula (a ∨ b) ∧ (b ∨ ¬c) :</p>
<pre style="background-color: #ffffff; color: #000000; font-family: 'Courier New'; margin-left: 30px;"><br /><span style="font-size: small;">    <span style="color: #000080; font-weight: bold;">public static void </span>main(String[] args) {</span><br /><span style="font-size: small;">        <span style="color: #000080; font-weight: bold;">int </span>n = <span style="color: #0000ff;">6</span>;</span><br /><span style="font-size: small;">        List&lt;Integer&gt;[] g = Stream.<span style="font-style: italic;">generate</span>(ArrayList::<span style="color: #000080; font-weight: bold;">new</span>).limit(n).toArray(List[]::<span style="color: #000080; font-weight: bold;">new</span>);</span><br /><br /><span style="font-size: small;">        <span style="color: #000080; font-weight: bold;">int </span>a = <span style="color: #0000ff;">0</span>, na = <span style="color: #0000ff;">1</span>, b = <span style="color: #0000ff;">2</span>, nb = <span style="color: #0000ff;">3</span>, c = <span style="color: #0000ff;">4</span>, nc = <span style="color: #0000ff;">5</span>;<br /></span><br /><span style="font-size: small;">        <span style="color: #808080; font-style: italic;">// (a \/ b) /\ (b \/ !c)  &lt;=&gt;<br /></span><span style="color: #808080; font-style: italic;">        </span>g[na].add(b);  <span style="color: #808080; font-style: italic;">// !a =&gt; b<br /></span><span style="color: #808080; font-style: italic;">        </span>g[nb].add(a);  <span style="color: #808080; font-style: italic;">// !b =&gt; a<br /></span><span style="color: #808080; font-style: italic;">        </span>g[nb].add(nc); <span style="color: #808080; font-style: italic;">// !b =&gt; !c<br /></span><span style="color: #808080; font-style: italic;">        </span>g[c].add(b);   <span style="color: #808080; font-style: italic;">// c =&gt; b<br /></span><span style="color: #808080; font-style: italic;"><br /></span><span style="color: #808080; font-style: italic;">        </span><span style="color: #000080; font-weight: bold;">boolean</span>[] solution = <span style="font-style: italic;">solve2Sat</span>(g);</span><br /><span style="font-size: small;">        System.<span style="color: #660e7a; font-weight: bold; font-style: italic;">out</span>.println(Arrays.<span style="font-style: italic;">toString</span>(solution));</span><br /><span style="font-size: small;">    }</span><br /><span style="font-size: small;">}</span></pre>
<p style="text-align: left;">Testem o código resolvendo o <a href="https://uva.onlinejudge.org/index.php?option=onlinejudge&amp;page=show_problem&amp;problem=1260">problema UVa 10319 - Manhattan</a>. Leiam a pg.337 do Halim que dá pistas para resolver este problema.</p>
<p style="text-align: left;"></p>

<div class="modified">Last modified: Wednesday, 21 June 2017, 1:01 PM</div>

</body>
</html>