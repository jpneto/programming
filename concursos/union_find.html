<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=yes">
  <meta name="description" content="How to use union find">
  <title>Union Find</title>
</head>

<body>

<h1 style="text-align: center;">Union Find</h1>
<center><span style="font-size: small;"><em>João Pedro Neto</em></span></center>

<p>Um <strong>union-find</strong>, ou conjunto disjunto (<em>disjoint-set</em>), é uma estrutura de dados que armazena conjuntos disjuntos de elementos.</p>
<p>Esta estrutura de dados possui as seguintes operações:</p>
<ul>
<li><strong>FIND</strong> - indica qual o conjunto que o elemento dado pertence. Cada conjunto é identificado por um elemento do conjunto chamado de <strong>representante</strong>. Para saber se dois elementos pertencem ao mesmo conjunto, faz-se um <em>find</em> para cada um, e verifica-se se possuem o mesmo representante.</li>
<li><strong>UNION</strong> - faz a união de dois dos seus conjuntos.</li>
<li><strong>MAKE-SET</strong> - dado um elemento, cria um conjunto com apenas esse elemento.</li>
</ul>
<p>Esta estrutura de dados é interessante porque é possível resolver com ela diversos problemas no UVa (já veremos um exemplo) e porque com uma correta implementação as operações são muito rápidas. É possível mostrar que a <a href="https://en.wikipedia.org/wiki/Amortized_analysis" target="_blank">complexidade amortizada</a> de cada operação é, para todos os efeitos práticos, O(1).</p>
<p>Leiam a secção 2.4.2 do livro do Halim para ver alguns exemplos de execução. Se quiserem saber mais vejam a entrada na <a href="https://en.wikipedia.org/wiki/Disjoint-set_data_structure" target="_blank">wikipedia</a> ou o capítulo 21 do livro do Cormen que possui o pseudo-código que inspirou a implementação Java que se segue:</p>
<pre style="margin-left: 30px;"><span style="font-size: small;"></span></pre>
<pre style="background-color: #ffffff; color: #000000; font-family: 'Courier New'; margin-left: 30px;"><span style="font-size: small;"><span style="color: #000080; font-weight: bold;">public class </span>Union_Find {</span><br />   <br /><span style="font-size: small;">    <span style="color: #808080; font-style: italic;">/*  The graph is represented as a forest of n-ary trees,<br /></span><span style="color: #808080; font-style: italic;">        which result in a linear search of a node<br /></span><span style="color: #808080; font-style: italic;">        (check details on CORMEN et al., chp.21) */<br /></span><span style="color: #808080; font-style: italic;"><br /></span><span style="color: #808080; font-style: italic;">    </span><span style="color: #000080; font-weight: bold;">int</span>[]   <span style="color: #660e7a; font-weight: bold;">p</span>, <span style="color: #808080; font-style: italic;">// p[i]    is the representative of i<br /></span><span style="color: #808080; font-style: italic;">         </span><span style="color: #660e7a; font-weight: bold;">rank</span>; <span style="color: #808080; font-style: italic;">// rank[i] is the height upper bound of i<br /></span><span style="color: #808080; font-style: italic;">   <br /></span><span style="color: #808080; font-style: italic;">    </span><span style="color: #000080; font-weight: bold;">public </span>Union_Find(<span style="color: #000080; font-weight: bold;">int </span>nNodes) {</span><br /><span style="font-size: small;">       <span style="color: #660e7a; font-weight: bold;">rank </span>= <span style="color: #000080; font-weight: bold;">new int</span>[nNodes]; <span style="color: #808080; font-style: italic;">// auto init to zero<br /></span><span style="color: #808080; font-style: italic;">       </span><span style="color: #660e7a; font-weight: bold;">p    </span>= <span style="color: #000080; font-weight: bold;">new int</span>[nNodes];</span><br />       <br /><span style="font-size: small;">       <span style="color: #000080; font-weight: bold;">for</span>(<span style="color: #000080; font-weight: bold;">int </span>i=<span style="color: #0000ff;">0</span>;i&lt;<span style="color: #660e7a; font-weight: bold;">p</span>.<span style="color: #660e7a; font-weight: bold;">length</span>;i++)</span><br /><span style="font-size: small;">          <span style="color: #660e7a; font-weight: bold;">p</span>[i]=i;</span><br /><span style="font-size: small;">    }</span><br />   <br /><span style="font-size: small;">    <span style="color: #000080; font-weight: bold;">public int </span>findSet(<span style="color: #000080; font-weight: bold;">int </span>x) {</span><br /><span style="font-size: small;">       <span style="color: #000080; font-weight: bold;">if </span>(x!=<span style="color: #660e7a; font-weight: bold;">p</span>[x])</span><br /><span style="font-size: small;">          <span style="color: #660e7a; font-weight: bold;">p</span>[x] = findSet(<span style="color: #660e7a; font-weight: bold;">p</span>[x]);</span><br /><span style="font-size: small;">       <span style="color: #000080; font-weight: bold;">return </span><span style="color: #660e7a; font-weight: bold;">p</span>[x];</span><br /><span style="font-size: small;">    }</span><br />   <br /><span style="font-size: small;">    <span style="color: #000080; font-weight: bold;">public void </span>union(<span style="color: #000080; font-weight: bold;">int </span>x, <span style="color: #000080; font-weight: bold;">int </span>y) {</span><br /><span style="font-size: small;">       link(findSet(x), findSet(y));</span><br /><span style="font-size: small;">    }</span><br />   <br /><span style="font-size: small;">    <span style="color: #000080; font-weight: bold;">private void </span>link(<span style="color: #000080; font-weight: bold;">int </span>x, <span style="color: #000080; font-weight: bold;">int </span>y) {</span><br /><span style="font-size: small;">       <span style="color: #000080; font-weight: bold;">if </span>(<span style="color: #660e7a; font-weight: bold;">rank</span>[x] &gt; <span style="color: #660e7a; font-weight: bold;">rank</span>[y])</span><br /><span style="font-size: small;">           <span style="color: #660e7a; font-weight: bold;">p</span>[y] = x;</span><br /><span style="font-size: small;">       <span style="color: #000080; font-weight: bold;">else </span>{</span><br /><span style="font-size: small;">           <span style="color: #660e7a; font-weight: bold;">p</span>[x] = y;</span><br /><span style="font-size: small;">           <span style="color: #000080; font-weight: bold;">if </span>(<span style="color: #660e7a; font-weight: bold;">rank</span>[x] == <span style="color: #660e7a; font-weight: bold;">rank</span>[y])</span><br /><span style="font-size: small;">              <span style="color: #660e7a; font-weight: bold;">rank</span>[y] = <span style="color: #660e7a; font-weight: bold;">rank</span>[y]+<span style="color: #0000ff;">1</span>;</span><br /><span style="font-size: small;">       }</span><br /><span style="font-size: small;">    }</span><br /><span style="font-size: small;">}</span></pre>
<hr />
<p>Vamos resolver um problema com <em>Union-Find</em>. </p>
<p>Leiam agora o enunciado do <a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=3601" target="_blank">UVa 1160</a>.</p>
<p style="text-align: center;"><em>momento de pausa...</em></p>
<p>Neste problema recebemos pares de "compostos" (que são inteiros) e que temos de processar. </p>
<p>Se usarmos a noção de conjuntos disjuntos, de início cada composto está isolado.</p>
<p>Quando chega o primeiro par, seja A+B, eles não pertencem ao mesmo conjunto mas podem ser unidos, dado que só se levantam problemas quando há N &gt;2 compostos ao mesmo tempo.</p>
<p>Ao chegar o 2º par de compostos, como não há repetições, pelo menos um dos elementos é diferente de A ou B. E nesse sentido podemos voltar a uni-los. Por exemplo, vamos considerar que era o par A+C. Tudo bem, temos 2 pares com 3 compostos (não dá explosão!)</p>
<p>Mas no 3º par podemos ter problemas (ou não). Vejamos um exemplo de cada:</p>
<ul>
<li>Chegou o par B+D. Aqui não há problema, após incluirmos o par, não há uma combinação perigosa, temos 3 pares e 4 compostos.</li>
<li>Chegou o par B+C. Este não podemos incluir, pois passaríamos a ter 3 pares com 3 compostos. Reparem que podia haver mais pares; o que nos interessa é que, dentro de todos os pares disponíveis, não podemos ter N pares com N compostos diferentes.</li>
</ul>
<p>Se tivermos N-1 pares com N compostos diferentes, não podemos receber um par com dois desses compostos! Isto significa que apenas devemos recusar pares de compostos, quando ambos já pertencem ao conjunto, pois isso permitiria ter a tal combinação perigosa.</p>
<p>Ora esta condição pode ser implementada pelo FIND e pelo UNION da classe acima.</p>
<p>Basicamente, quando recebemos um novo par, perguntamos se ambos têm o mesmo representante. Se sim, recusamos (e actualizamos o número de recusas, que é o que queremos fazer <em>output</em>). Se não, então unimos os dois compostos no mesmo conjunto.</p>
<pre style="margin-left: 30px;"><span style="font-size: small;"></span></pre>
<pre style="background-color: #ffffff; color: #000000; font-family: 'Courier New'; margin-left: 30px;"><span style="font-size: small;"><span style="color: #000080; font-weight: bold;">public class </span>UVa_1160_X_Plosives {</span><br />   <br /><span style="font-size: small;">    <span style="color: #000080; font-weight: bold;">public static void </span>main(String[] args) <span style="color: #000080; font-weight: bold;">throws </span>IOException {</span><br /><br /><span style="font-size: small;">      <span style="color: #000080; font-weight: bold;">if </span>(!<span style="color: #000080; font-weight: bold;">new </span>Object(){}.getClass().getName().contains(<span style="color: #008000; font-weight: bold;">"Main"</span>))    </span><br /><span style="font-size: small;">         <span style="color: #000080; font-weight: bold;">try </span>{   <span style="color: #808080; font-style: italic;">// redirect System.in and System.out to in/out text files<br /></span><span style="color: #808080; font-style: italic;">            </span>System.<span style="font-style: italic;">setIn </span>(<span style="color: #000080; font-weight: bold;">new </span>FileInputStream(<span style="color: #008000; font-weight: bold;">"data/uva1160.in.txt" </span>));</span><br /><span style="font-size: small;">            System.<span style="font-style: italic;">setOut</span>(<span style="color: #000080; font-weight: bold;">new     </span>PrintStream(<span style="color: #008000; font-weight: bold;">"data/uva1160.out.txt"</span>) );</span><br /><span style="font-size: small;">         } <span style="color: #000080; font-weight: bold;">catch </span>(Exception e) {}      </span><br /><span style="font-size: small;">      <span style="color: #808080; font-style: italic;">///////////////////////////////////////////////////////////////<br /></span><span style="color: #808080; font-style: italic;">       <br /></span><span style="color: #808080; font-style: italic;">      </span>Reader1.<span style="font-style: italic;">init</span>( System.<span style="color: #660e7a; font-weight: bold; font-style: italic;">in </span>);    </span><br />      <br /><span style="font-size: small;">      <span style="color: #000080; font-weight: bold;">while </span>(Reader1.<span style="font-style: italic;">hasNext</span>()) {</span><br /><span style="font-size: small;">          Union_Find uf = <span style="color: #000080; font-weight: bold;">new </span>Union_Find(<span style="color: #0000ff;">100000</span>);</span><br /><span style="font-size: small;">         <span style="color: #000080; font-weight: bold;">int </span>refusals = <span style="color: #0000ff;">0</span>;</span><br /><span style="font-size: small;">          <span style="color: #000080; font-weight: bold;">do </span>{</span><br /><span style="font-size: small;">              <span style="color: #000080; font-weight: bold;">int </span>x = Reader1.<span style="font-style: italic;">nextInt</span>();  </span><br /><span style="font-size: small;">              <span style="color: #000080; font-weight: bold;">if </span>(x==-<span style="color: #0000ff;">1</span>) </span><br /><span style="font-size: small;">                 <span style="color: #000080; font-weight: bold;">break</span>;</span><br /><span style="font-size: small;">              <span style="color: #000080; font-weight: bold;">int </span>y = Reader1.<span style="font-style: italic;">nextInt</span>();</span><br /><br /><span style="font-size: small;">              <span style="color: #000080; font-weight: bold;">if </span>(uf.findSet(x) == uf.findSet(y)) <span style="color: #808080; font-style: italic;">// elements already on the same graph?<br /></span><span style="color: #808080; font-style: italic;">                  </span>refusals++;</span><br /><span style="font-size: small;">              <span style="color: #000080; font-weight: bold;">else                                </span><span style="color: #808080; font-style: italic;">// if not, join their graphs<br /></span><span style="color: #808080; font-style: italic;">                 </span>uf.union(x,y);</span><br /><span style="font-size: small;">          } <span style="color: #000080; font-weight: bold;">while </span>(<span style="color: #000080; font-weight: bold;">true</span>);</span><br /><br /><span style="font-size: small;">          System.<span style="color: #660e7a; font-weight: bold; font-style: italic;">out</span>.println(refusals);</span><br /><span style="font-size: small;">       }</span><br /><span style="font-size: small;">    }</span><br /><span style="font-size: small;">}</span></pre>
<pre style="margin-left: 30px;"><span style="font-size: small;"> </span></pre>
<p>A classe <span style="font-family: 'courier new', courier, monospace;">Reader1</span> foi usada dado que o <em>input</em> é muito grande e o <span style="font-family: 'courier new', courier, monospace;">Scanner</span> nestas situações demora muito tempo (vejam o <a href="https://moodle.ciencias.ulisboa.pt/mod/page/view.php?id=113888" target="_blank">guião</a> sobre este assunto).</p>
<p>Eis o seu código:</p>
<pre style="margin-left: 30px;"><span style="font-size: small;"></span></pre>
<pre style="background-color: #ffffff; color: #000000; font-family: 'Courier New'; margin-left: 30px;"><span style="font-size: small;"><span style="color: #000080; font-weight: bold;">class </span>Reader1 {</span><br /><span style="font-size: small;">    <span style="color: #000080; font-weight: bold;">static </span>BufferedReader <span style="color: #660e7a; font-style: italic;">reader</span>;</span><br /><span style="font-size: small;">    <span style="color: #000080; font-weight: bold;">static </span>StringTokenizer <span style="color: #660e7a; font-style: italic;">tokenizer</span>;</span><br /><span style="font-size: small;">    <span style="color: #000080; font-weight: bold;">static </span>String <span style="color: #660e7a; font-style: italic;">next</span>;</span><br /><span style="font-size: small;">    <span style="color: #000080; font-weight: bold;">static boolean </span><span style="color: #660e7a; font-style: italic;">eof</span>;</span><br /><br /><span style="font-size: small;">    <span style="color: #808080; font-style: italic;">/** call this method to initialize reader for InputStream <br /></span><span style="color: #808080; font-style: italic;">     * </span><span style="color: #808080; font-weight: bold; font-style: italic;">@throws </span><span style="color: #808080; font-style: italic;">IOException <br /></span><span style="color: #808080; font-style: italic;">     */<br /></span><span style="color: #808080; font-style: italic;">    </span><span style="color: #000080; font-weight: bold;">static void </span>init(InputStream input) <span style="color: #000080; font-weight: bold;">throws </span>IOException {</span><br /><span style="font-size: small;">        <span style="color: #660e7a; font-style: italic;">reader </span>= <span style="color: #000080; font-weight: bold;">new </span>BufferedReader( <span style="color: #000080; font-weight: bold;">new </span>InputStreamReader(input) );</span><br /><span style="font-size: small;">        <span style="color: #660e7a; font-style: italic;">tokenizer </span>= <span style="color: #000080; font-weight: bold;">new </span>StringTokenizer(<span style="color: #008000; font-weight: bold;">""</span>);</span><br /><span style="font-size: small;">        <span style="color: #660e7a; font-style: italic;">next </span>= <span style="color: #660e7a; font-style: italic;">reader</span>.readLine();</span><br /><span style="font-size: small;">    }</span><br />    <br /><span style="font-size: small;">    <span style="color: #000080; font-weight: bold;">static boolean </span>hasNext() {</span><br /><span style="font-size: small;">       <span style="color: #000080; font-weight: bold;">return </span><span style="color: #660e7a; font-style: italic;">tokenizer</span>.hasMoreTokens() || <span style="color: #660e7a; font-style: italic;">next</span>!=<span style="color: #000080; font-weight: bold;">null</span>;</span><br /><span style="font-size: small;">    }</span><br /><br /><span style="font-size: small;">    <span style="color: #808080; font-style: italic;">/** get next word<br /></span><span style="color: #808080; font-style: italic;">     * </span><span style="color: #808080; font-weight: bold; font-style: italic;">@throws </span><span style="color: #808080; font-style: italic;">IOException <br /></span><span style="color: #808080; font-style: italic;">     */<br /></span><span style="color: #808080; font-style: italic;">    </span><span style="color: #000080; font-weight: bold;">static </span>String next() <span style="color: #000080; font-weight: bold;">throws </span>IOException {</span><br /><span style="font-size: small;">        <span style="color: #000080; font-weight: bold;">while </span>( ! <span style="color: #660e7a; font-style: italic;">tokenizer</span>.hasMoreTokens() ) {</span><br /><span style="font-size: small;">           <span style="color: #000080; font-weight: bold;">if </span>(<span style="color: #660e7a; font-style: italic;">next </span>== <span style="color: #000080; font-weight: bold;">null</span>) <span style="color: #000080; font-weight: bold;">return null</span>;</span><br /><span style="font-size: small;">           <span style="color: #660e7a; font-style: italic;">tokenizer </span>= <span style="color: #000080; font-weight: bold;">new </span>StringTokenizer( <span style="color: #660e7a; font-style: italic;">next </span>);</span><br /><span style="font-size: small;">            <span style="color: #660e7a; font-style: italic;">next </span>= <span style="color: #660e7a; font-style: italic;">reader</span>.readLine();</span><br /><span style="font-size: small;">        }</span><br /><span style="font-size: small;">           <span style="color: #000080; font-weight: bold;">return </span><span style="color: #660e7a; font-style: italic;">tokenizer</span>.nextToken();</span><br /><span style="font-size: small;">    }</span><br /><br /><span style="font-size: small;">    <span style="color: #000080; font-weight: bold;">static int </span>nextInt() <span style="color: #000080; font-weight: bold;">throws </span>IOException {</span><br /><span style="font-size: small;">        <span style="color: #000080; font-weight: bold;">return </span>Integer.<span style="font-style: italic;">parseInt</span>( <span style="font-style: italic;">next</span>() );</span><br /><span style="font-size: small;">    }</span><br /><span style="font-size: small;">}</span></pre>
<hr />
<p>Outros problemas UVa sugeridos:</p>
<ul>
<li><a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=734" target="_blank">UVa 00793 - Network Connections</a></li>
<li><a href="https://uva.onlinejudge.org/index.php?option=onlinejudge&amp;page=show_problem&amp;problem=1168" target="_blank">UVa 10227 - Forests</a></li>
<li><a href="https://uva.onlinejudge.org/index.php?option=onlinejudge&amp;page=show_problem&amp;problem=2498" target="_blank">UVa 11503 - Virtual Friends</a></li>
</ul></div></div><div class="modified">Last modified: Thursday, 3 November 2016, 10:30 AM</div></div>

</body>
</html>