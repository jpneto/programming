<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=yes">
  <meta name="description" content="How to use graphs">
  <title>Grafos - Árvore Geradora Mínima</title>
</head>

<body>

<h1 style="text-align: center;">Grafos - Árvore Geradora Mínima</h1>
<center><span style="font-size: small;"><em>João Pedro Neto</em></span></center>

<p>A árvore geradora mínima, em inglês, <em>minimal spanning tree</em> (MST), de um grafo G é um subconjunto de arestas de G que definem uma árvore geradora (uma árvore que contenha todos os nós de G) e possui a soma mínima das arestas escolhidas.</p>
<p>Eis um exemplo (tirado do livro do Halim):</p>
<p style="text-align: center;"><img src="imgs/graph_mstree.jpg" width="545" height="284" /></p>
<p>Se o grafo G tem V nós, a MST(G) terá de ter V-1 arestas.</p>
<p>O seguinte método usa o <a href="https://en.wikipedia.org/wiki/Kruskal%27s_algorithm">algoritmo de Kruskal </a>que faz o seguinte:</p>
<p style="margin-left: 30px;">1. cria uma floresta F (um conjunto de árvores) em que cada nós do grafo é uma árvore separada<br />2. cria um conjunto S com todas as arestas do grafo<br />3. enquanto S não é vazio e a floresta F não é apenas uma árvore geradora:<br />   a. remove a aresta de S com peso mínimo<br />   b. se esta aresta conecta duas árvores separadas, juntar as duas árvores numa só</p>
<p>A junção dos elementos disjuntos vai ser realizado pelo algoritmo de Union-Find que já falámos noutra sessão (e que está disponível no moodle).</p>
<p>Em Java:</p>
<pre style="background-color: #ffffff; color: #000000; font-family: 'Courier New'; margin-left: 30px;"><span style="font-size: small;">    <span style="color: #808080; font-style: italic;">/**<br /></span><span style="color: #808080; font-style: italic;">     * Computes a minimum spanning tree of this graph using Kruskal's Algorithm<br /></span><span style="color: #808080; font-style: italic;">     * Cf. https://en.wikipedia.org/wiki/Kruskal's_algorithm<br /></span><span style="color: #808080; font-style: italic;">     * </span><span style="color: #808080; font-weight: bold; font-style: italic;">@complexity </span><span style="color: #808080; font-style: italic;">O(E log V)<br /></span><span style="color: #808080; font-style: italic;">     * </span><span style="color: #808080; font-weight: bold; font-style: italic;">@requires </span><span style="color: #808080; font-style: italic;">an undirected graph<br /></span><span style="color: #808080; font-style: italic;">     * </span><span style="color: #808080; font-weight: bold; font-style: italic;">@return </span><span style="color: #808080; font-style: italic;">a set of edges inside an int[]. <br /></span><span style="color: #808080; font-style: italic;">     *         Eg, if the result was 1-&gt;2 and 2-&gt;4, it returns [1,2,2,4]<br /></span><span style="color: #808080; font-style: italic;">     */<br /></span><span style="color: #808080; font-style: italic;">    </span><span style="color: #000080; font-weight: bold;">public int</span>[] minimumSpanningTree() {</span><br /><span style="font-size: small;">       ArrayList&lt;Integer&gt; l = <span style="color: #000080; font-weight: bold;">new </span>ArrayList&lt;Integer&gt;();</span><br /><span style="font-size: small;">       Union_Find        uf = <span style="color: #000080; font-weight: bold;">new </span>Union_Find(<span style="color: #660e7a; font-weight: bold;">size</span>);</span><br /><span style="font-size: small;">       <span style="color: #000080; font-weight: bold;">int</span>[]          edges = sortEdgesByWeight();</span><br /><br /><span style="font-size: small;">       <span style="color: #000080; font-weight: bold;">for</span>(<span style="color: #000080; font-weight: bold;">int </span>i=<span style="color: #0000ff;">0</span>; i&lt;edges.<span style="color: #660e7a; font-weight: bold;">length</span>; i+=<span style="color: #0000ff;">2</span>)</span><br /><span style="font-size: small;">          <span style="color: #000080; font-weight: bold;">if </span>(uf.findSet(edges[i]) != uf.findSet(edges[i+<span style="color: #0000ff;">1</span>])) {</span><br /><span style="font-size: small;">             l.add(edges[ i ]);</span><br /><span style="font-size: small;">             l.add(edges[i+<span style="color: #0000ff;">1</span>]);</span><br /><span style="font-size: small;">             uf.union(edges[i], edges[i+<span style="color: #0000ff;">1</span>]);</span><br /><span style="font-size: small;">          }</span><br /><span style="font-size: small;">       <span style="color: #000080; font-weight: bold;">return </span>list2array(l);</span><br /><span style="font-size: small;">    }</span><br /><br /><span style="font-size: small;">    <span style="color: #808080; font-style: italic;">// Auxiliary class that creates a comparable edge <br /></span><span style="color: #808080; font-style: italic;">    // Useful to use Collection.sort()<br /></span><span style="color: #808080; font-style: italic;">    </span><span style="color: #808000;">@SuppressWarnings</span>(<span style="color: #008000; font-weight: bold;">"rawtypes"</span>)</span><br /><span style="font-size: small;">   <span style="color: #000080; font-weight: bold;">private class </span>Triple <span style="color: #000080; font-weight: bold;">implements </span>Comparable {</span><br /><span style="font-size: small;">       <span style="color: #000080; font-weight: bold;">int </span><span style="color: #660e7a; font-weight: bold;">from</span>, <span style="color: #660e7a; font-weight: bold;">to</span>;</span><br /><span style="font-size: small;">       Integer <span style="color: #660e7a; font-weight: bold;">weight</span>;</span><br /><br /><span style="font-size: small;">       <span style="color: #000080; font-weight: bold;">public </span>Triple(<span style="color: #000080; font-weight: bold;">int </span>f, <span style="color: #000080; font-weight: bold;">int </span>t, <span style="color: #000080; font-weight: bold;">int </span>w) {</span><br /><span style="font-size: small;">          <span style="color: #660e7a; font-weight: bold;">from </span>= f; <span style="color: #660e7a; font-weight: bold;">to </span>= t; <span style="color: #660e7a; font-weight: bold;">weight </span>= <span style="color: #000080; font-weight: bold;">new </span>Integer(w);</span><br /><span style="font-size: small;">       }</span><br /><br /><span style="font-size: small;">      <span style="color: #808000;">@Override<br /></span><span style="color: #808000;">      </span><span style="color: #000080; font-weight: bold;">public int </span>compareTo(Object obj) {</span><br /><span style="font-size: small;">         <span style="color: #000080; font-weight: bold;">return </span><span style="color: #660e7a; font-weight: bold;">weight</span>.compareTo(((Triple)obj).<span style="color: #660e7a; font-weight: bold;">weight</span>);</span><br /><span style="font-size: small;">      }</span><span style="font-size: small;"><span style="color: #808080; font-style: italic;"><br /></span><span style="color: #808080; font-style: italic;">    </span>}</span><br /><br /><span style="font-size: small;">    <span style="color: #808080; font-style: italic;">// returns the edges sorted by weight (increasing) in an int[]<br /></span><span style="color: #808080; font-style: italic;">    // eg, if 1-{2}-&gt;3 and 0-{1}-&gt;4, the result is [0,4,1,3]<br /></span><span style="color: #808080; font-style: italic;">    </span><span style="color: #808000;">@SuppressWarnings</span>(<span style="color: #008000; font-weight: bold;">"unchecked"</span>)</span><br /><span style="font-size: small;">    <span style="color: #000080; font-weight: bold;">private int</span>[] sortEdgesByWeight() {</span><br /><span style="font-size: small;">       ArrayList&lt;Triple&gt; l = <span style="color: #000080; font-weight: bold;">new </span>ArrayList&lt;Triple&gt;();</span><br /><br /><span style="font-size: small;">       <span style="color: #000080; font-weight: bold;">for</span>(<span style="color: #000080; font-weight: bold;">int </span>row=<span style="color: #0000ff;">0</span>; row&lt;<span style="color: #660e7a; font-weight: bold;">size</span>; row++)       <span style="color: #808080; font-style: italic;">// copy all non-zero edges to list<br /></span><span style="color: #808080; font-style: italic;">          </span><span style="color: #000080; font-weight: bold;">for</span>(<span style="color: #000080; font-weight: bold;">int </span>col=<span style="color: #0000ff;">0</span>; col&lt;row; col++) {</span><br /><span style="font-size: small;">             <span style="color: #000080; font-weight: bold;">int </span>w = weight(row,col);</span><br /><span style="font-size: small;">             <span style="color: #000080; font-weight: bold;">if </span>(w!=<span style="color: #0000ff;">0</span>)</span><br /><span style="font-size: small;">                l.add(<span style="color: #000080; font-weight: bold;">new </span>Triple(row,col,w));</span><br /><span style="font-size: small;">          }</span><br /><br /><span style="font-size: small;">       Collections.<span style="font-style: italic;">sort</span>(l);</span><br /><br /><span style="font-size: small;">       <span style="color: #000080; font-weight: bold;">int</span>[] result = <span style="color: #000080; font-weight: bold;">new int</span>[<span style="color: #0000ff;">2</span>*l.size()];  <span style="color: #808080; font-style: italic;">// translate list of Triples to int[]<br /></span><span style="color: #808080; font-style: italic;">       </span><span style="color: #000080; font-weight: bold;">int </span>i = <span style="color: #0000ff;">0</span>;</span><br /><span style="font-size: small;">       <span style="color: #000080; font-weight: bold;">for</span>(Triple t : l) {</span><br /><span style="font-size: small;">          result[i++] = t.<span style="color: #660e7a; font-weight: bold;">from</span>;</span><br /><span style="font-size: small;">          result[i++] = t.<span style="color: #660e7a; font-weight: bold;">to</span>;</span><br /><span style="font-size: small;">       }</span><br /><span style="font-size: small;">      <span style="color: #000080; font-weight: bold;">return </span>result;</span><br /><span style="font-size: small;">    }</span></pre>
<p>O método seguinte é útil para calcular o custo da MST:</p>
<pre style="background-color: #ffffff; color: #000000; font-family: 'Courier New'; margin-left: 30px;"><span style="font-size: small;"><span style="color: #808080; font-style: italic;">/**<br /></span><span style="color: #808080; font-style: italic;"> * Compute the cost of the minimum spanning tree<br /></span><span style="color: #808080; font-style: italic;"> * </span><span style="color: #808080; font-weight: bold; font-style: italic;">@param </span><span style="color: #3d3d3d; font-weight: bold; font-style: italic;">edges </span><span style="color: #808080; font-style: italic;">array of indexes. Eg, if MST is 1-&gt;2 2-&gt;3, edges=[1,2,2,3]<br /></span><span style="color: #808080; font-style: italic;"> * </span><span style="color: #808080; font-weight: bold; font-style: italic;">@return </span><span style="color: #808080; font-style: italic;">the cumulative cost of all given edges<br /></span><span style="color: #808080; font-style: italic;"> */<br /></span><span style="color: #000080; font-weight: bold;">public int </span>costMST(<span style="color: #000080; font-weight: bold;">int</span>[] edges) {</span><br /><span style="font-size: small;">   <span style="color: #000080; font-weight: bold;">int </span>sum=<span style="color: #0000ff;">0</span>;</span><br /><br /><span style="font-size: small;">   <span style="color: #000080; font-weight: bold;">for</span>(<span style="color: #000080; font-weight: bold;">int </span>i=<span style="color: #0000ff;">0</span>; i&lt;edges.<span style="color: #660e7a; font-weight: bold;">length</span>; i+=<span style="color: #0000ff;">2</span>)</span><br /><span style="font-size: small;">      sum += weight(edges[i], edges[i+<span style="color: #0000ff;">1</span>]);</span><br /><span style="font-size: small;">   <span style="color: #000080; font-weight: bold;">return </span>sum;</span><br /><span style="font-size: small;">}</span></pre>
<p>Leiam o capítulo 4.3 do livro do Halim para mais informação sobre este algoritmo.</p>
<p>Problemas relacionados:</p>
<ul>
<li><a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;category=24&amp;problem=849">UVa 908 - Re-connecting</a></li>
<li><a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=975">UVa 10034 - Freckles</a></li>
<li><a href="https://uva.onlinejudge.org/index.php?option=onlinejudge&amp;page=show_problem&amp;problem=2169">UVa 11228 - Transportation System</a></li>
<li><a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=2847">UVa 11747 - Heavy Cycle Edges</a></li>
</ul>

<div class="modified">Last modified: Wednesday, 21 June 2017, 11:16 AM</div>

</body>
</html>