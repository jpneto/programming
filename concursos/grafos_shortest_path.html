<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=yes">
  <meta name="description" content="How to use graphs">
  <title>Grafos - Caminho Mais Curto</title>
</head>

<body>

<h1 style="text-align: center;">Grafos - Caminho Mais Curto</h1>
<center><span style="font-size: small;"><em>João Pedro Neto</em></span></center>

<p>O problema do caminho mais curto passa por encontrar, entre todos os caminhos possíveis entre dois nós de um grafo, aquele cujo custo é menor. </p>
<p>O custo de um caminho é a soma dos pesos das arestas que compõem esse caminho.</p>
<p>Por exemplo (<a href="https://en.wikipedia.org/wiki/Shortest_path_problem">ref</a>):</p>
<p style="text-align: center;"><img src="imgs/graph_shortest_path_eg.png" width="250" height="136" /></p>
<p>O caminho mais curto entre A e F é dado pelos nós a azul, e o seu custo é dado por 2+3+4+11=20.</p>
<p>Existem dois caminhos alternativos, ABDF de custo 25, e ABCEDF de custo 27.</p>
<h4>Algoritmo</h4>
<p>Existem diversos algoritmos que permitem obter a solução. </p>
<p>O algoritmo que iremos implementar é a <a href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm">solução</a> proposta por Dijkstra, sendo um algoritmo ganancioso (<em>greedy algorithm</em>).</p>
<p>Este algoritmo tem complexidade O( V<sup>2 </sup>) sendo V o número de nós.</p>
<p>Podem visualizar uma explicação do algoritmo neste tutorial:</p>
<center><iframe src="https://www.youtube.com/embed/8Ls1RqHCOPw" allowfullscreen="" width="504" height="378" frameborder="0"></iframe></center>
<p></p>
<p>O seguinte método implementa o algoritmo de Dijkstra usando as funcionalidades da classe <strong>Graph</strong>.</p>
<p>O método devolve <strong>null</strong> se não existir um caminho.</p>
<pre style="background-color: #ffffff; color: #000000; font-family: 'Courier New'; margin-left: 30px;"><span style="font-size: small;"><span style="color: #808080; font-style: italic;">/**<br /></span><span style="color: #808080; font-style: italic;"> * Compute Shortest Path using Dijkstra's greedy algorithm<br /></span><span style="color: #808080; font-style: italic;"> * </span><span style="color: #808080; font-weight: bold; font-style: italic;">@complexity </span><span style="color: #808080; font-style: italic;">O(V</span>^<span style="color: #808080; font-style: italic;">2)<br /></span><span style="color: #808080; font-style: italic;"> * </span><span style="color: #808080; font-weight: bold; font-style: italic;">@return </span><span style="color: #808080; font-style: italic;">an array with the indexes of the path, or null if no path exists<br /></span><span style="color: #808080; font-style: italic;"> */<br /></span><span style="color: #000080; font-weight: bold;">public int</span>[] shortestPath(<span style="color: #000080; font-weight: bold;">int </span>from, <span style="color: #000080; font-weight: bold;">int </span>to) {</span><br /><br /><span style="font-size: small;">   <span style="color: #000080; font-weight: bold;">int</span>[] costs = <span style="color: #000080; font-weight: bold;">new int</span>[<span style="color: #660e7a; font-weight: bold;">size</span>];</span><br /><span style="font-size: small;">   <span style="color: #000080; font-weight: bold;">for</span>(<span style="color: #000080; font-weight: bold;">int </span>i=<span style="color: #0000ff;">0</span>; i&lt;<span style="color: #660e7a; font-weight: bold;">size </span>; i++)             <span style="color: #808080; font-style: italic;">// init costs<br /></span><span style="color: #808080; font-style: italic;">      </span>costs[i] = Integer.<span style="color: #660e7a; font-weight: bold; font-style: italic;">MAX_VALUE</span>-<span style="color: #0000ff;">1</span>;</span><br /><span style="font-size: small;">   costs[from] = <span style="color: #0000ff;">0</span>;</span><br /><br /><span style="font-size: small;">   <span style="color: #000080; font-weight: bold;">boolean</span>[] visited = <span style="color: #000080; font-weight: bold;">new boolean</span>[<span style="color: #660e7a; font-weight: bold;">size</span>];</span><br /><span style="font-size: small;">   <span style="color: #000080; font-weight: bold;">int </span>visitedNodes = <span style="color: #0000ff;">0</span>;</span><br /><br /><span style="font-size: small;">   <span style="color: #000080; font-weight: bold;">int</span>[] prev = <span style="color: #000080; font-weight: bold;">new int</span>[<span style="color: #660e7a; font-weight: bold;">size</span>];</span><br /><br /><span style="font-size: small;">   <span style="color: #000080; font-weight: bold;">while</span>(visitedNodes++ &lt; <span style="color: #660e7a; font-weight: bold;">size</span>) {</span><br /><span style="font-size: small;">      <span style="color: #808080; font-style: italic;">// select unvisited node with min cost<br /></span><span style="color: #808080; font-style: italic;">      </span><span style="color: #000080; font-weight: bold;">int </span>min = -<span style="color: #0000ff;">1</span>, minCost = Integer.<span style="color: #660e7a; font-weight: bold; font-style: italic;">MAX_VALUE</span>;</span><br /><span style="font-size: small;">      <span style="color: #000080; font-weight: bold;">for</span>(<span style="color: #000080; font-weight: bold;">int </span>i=<span style="color: #0000ff;">0</span>; i&lt;<span style="color: #660e7a; font-weight: bold;">size </span>; i++)</span><br /><span style="font-size: small;">         <span style="color: #000080; font-weight: bold;">if </span>(!visited[i] &amp;&amp; costs[i]&lt;minCost) {</span><br /><span style="font-size: small;">            min = i;</span><br /><span style="font-size: small;">            minCost = costs[i];</span><br /><span style="font-size: small;">         }</span><br /><br /><span style="font-size: small;">      <span style="color: #000080; font-weight: bold;">if </span>(minCost==Integer.<span style="color: #660e7a; font-weight: bold; font-style: italic;">MAX_VALUE</span>-<span style="color: #0000ff;">1</span>) <span style="color: #808080; font-style: italic;">// no need to continue<br /></span><span style="color: #808080; font-style: italic;">         </span><span style="color: #000080; font-weight: bold;">break</span>;</span><br /><br /><span style="font-size: small;">      <span style="color: #000080; font-weight: bold;">for</span>(<span style="color: #000080; font-weight: bold;">int </span>succ : sucessors(min))</span><br /><span style="font-size: small;">         <span style="color: #000080; font-weight: bold;">if </span>(minCost + weight(min,succ) &lt; costs[succ]) {</span><br /><span style="font-size: small;">            costs[succ] = minCost + weight(min,succ);</span><br /><span style="font-size: small;">            prev[succ]  = min;</span><br /><span style="font-size: small;">         }</span><br /><span style="font-size: small;">      visited[min] = <span style="color: #000080; font-weight: bold;">true</span>;</span><br /><span style="font-size: small;">   }</span><br /><br /><span style="font-size: small;">   <span style="color: #808080; font-style: italic;">// construct array with shortest path<br /></span><span style="color: #808080; font-style: italic;">   </span>ArrayList&lt;Integer&gt; l = <span style="color: #000080; font-weight: bold;">new </span>ArrayList&lt;Integer&gt;();</span><br /><br /><span style="font-size: small;">   l.add(to);</span><br /><span style="font-size: small;">   <span style="color: #000080; font-weight: bold;">while</span>(prev[l.get(<span style="color: #0000ff;">0</span>)] != from) {</span><br /><span style="font-size: small;">      <span style="color: #000080; font-weight: bold;">if </span>(l.size() &gt; <span style="color: #660e7a; font-weight: bold;">size</span>)      <span style="color: #808080; font-style: italic;">// something went wrong, no path is possible<br /></span><span style="color: #808080; font-style: italic;">         </span><span style="color: #000080; font-weight: bold;">return null</span>;</span><br /><span style="font-size: small;">      l.add(<span style="color: #0000ff;">0</span>, prev[l.get(<span style="color: #0000ff;">0</span>)]); <span style="color: #808080; font-style: italic;">// add to begin of list, so the order is from --&gt; to<br /></span><span style="color: #808080; font-style: italic;">   </span>}</span><br /><span style="font-size: small;">   l.add(<span style="color: #0000ff;">0</span>,from);</span><br /><span style="font-size: small;">   <span style="color: #000080; font-weight: bold;">return </span>list2array(l);</span><br /><span style="font-size: small;">}</span></pre>
<p>Com este método podemos saber se dois nós estão conectados entre si:</p>
<pre style="background-color: #ffffff; color: #000000; font-family: 'Courier New'; margin-left: 30px;"><span style="font-size: small;"><span style="color: #808080; font-style: italic;">/**<br /></span><span style="color: #808080; font-style: italic;"> * Is there a path from 'from' to 'to'? <br /></span><span style="color: #808080; font-style: italic;"> * </span><span style="color: #808080; font-weight: bold; font-style: italic;">@complexity </span><span style="color: #808080; font-style: italic;">O(V</span>^<span style="color: #808080; font-style: italic;">2)<br /></span><span style="color: #808080; font-style: italic;"> */<br /></span><span style="color: #000080; font-weight: bold;">public boolean </span>isConnected(<span style="color: #000080; font-weight: bold;">int </span>from, <span style="color: #000080; font-weight: bold;">int </span>to) {</span><br /><span style="font-size: small;">   <span style="color: #000080; font-weight: bold;">return </span>shortestPath(from, to) != <span style="color: #000080; font-weight: bold;">null</span>;</span><br /><span style="font-size: small;">}</span></pre>
<p>Para experimentar tentem resolver o <a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=1455">UVa 10514</a>.</p>
<p>Tentem depois resolver alguns problemas desta <a href="http://www.spoj.com/problems/tag/dijkstra-s-algorithm">lista</a> que usam o algoritmo do caminho mais curto.</p>

<div class="modified">Last modified: Wednesday, 21 June 2017, 10:04 AM</div>

</body>
</html>