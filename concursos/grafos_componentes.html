<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=yes">
  <meta name="description" content="How to use graphs">
  <title>Grafos - Componentes de Grafo</title>
</head>

<body>

<h1 style="text-align: center;">Grafos - Componentes de Grafo</h1>
<center><span style="font-size: small;"><em>João Pedro Neto</em></span></center>

<p>Uma componente de um grafo não orientado (undirected graph) é um conjunto de nós que têm caminhos entre si.</p>
<p>No exemplo seguinte podemos observar um grafo com três componentes (reparem que os arcos não têm setas porque o grafo é não orientado):</p>
<p><img src="imgs/graph_connected_components.gif" style="display: block; margin-left: auto; margin-right: auto;" width="322" height="284" /></p>
<p>Para calcular quais são os componentes de um grafo podemos executar o seguinte algoritmo:</p>
<p>1. Definir todos os nós como não visitados<br />2. Para o próximo nó V não visitado:<br />   a) aplicar Depth-First-Search(V) e marcar esses nós como visitados</p>
<p>Em Java vamos criar um método que devolve um vector de vetores (cada um é um componente que possui os índices dos seus nós):</p>
<pre style="background-color: #ffffff; color: #000000; font-family: 'Courier New'; margin-left: 30px;"><span style="font-size: small;"><span style="color: #808080; font-style: italic;">/**<br /></span><span style="color: #808080; font-style: italic;"> * Find connected components of an undirected graph<br /></span><span style="color: #808080; font-style: italic;"> * </span><span style="color: #808080; font-weight: bold; font-style: italic;">@requires </span><span style="color: #808080; font-style: italic;">an undirected graph<br /></span><span style="color: #808080; font-style: italic;"> * </span><span style="color: #808080; font-weight: bold; font-style: italic;">@complexity </span><span style="color: #808080; font-style: italic;">O(V </span>+ <span style="color: #808080; font-style: italic;">E)<br /></span><span style="color: #808080; font-style: italic;"> * </span><span style="color: #808080; font-weight: bold; font-style: italic;">@return </span><span style="color: #808080; font-style: italic;">An array of components (each component is an array of connected nodes)<br /></span><span style="color: #808080; font-style: italic;"> */<br /></span><span style="color: #000080; font-weight: bold;">public int</span>[][] components() {</span><br /><span style="font-size: small;">   <span style="color: #000080; font-weight: bold;">boolean</span>[] visited  = <span style="color: #000080; font-weight: bold;">new boolean</span>[<span style="color: #660e7a; font-weight: bold;">size</span>];</span><br /><span style="font-size: small;">   ArrayList&lt;<span style="color: #000080; font-weight: bold;">int</span>[]&gt; l = <span style="color: #000080; font-weight: bold;">new </span>ArrayList&lt;<span style="color: #000080; font-weight: bold;">int</span>[]&gt;();</span><br /><br /><span style="font-size: small;">   <span style="color: #000080; font-weight: bold;">while</span>(<span style="color: #000080; font-weight: bold;">true</span>) {</span><br /><span style="font-size: small;">      <span style="color: #000080; font-weight: bold;">int </span>next = <span style="color: #0000ff;">0</span>;</span><br /><span style="font-size: small;">      <span style="color: #000080; font-weight: bold;">for</span>(;next&lt;<span style="color: #660e7a; font-weight: bold;">size </span>&amp;&amp; visited[next];next++); <span style="color: #808080; font-style: italic;">// find next unvisited node<br /></span><span style="color: #808080; font-style: italic;">      </span><span style="color: #000080; font-weight: bold;">if </span>(next==<span style="color: #660e7a; font-weight: bold;">size</span>)                          <span style="color: #808080; font-style: italic;">// no more nodes to visit<br /></span><span style="color: #808080; font-style: italic;">         </span><span style="color: #000080; font-weight: bold;">break</span>;</span><br /><br /><span style="font-size: small;">      <span style="color: #000080; font-weight: bold;">int</span>[] nodes = dfs(next);</span><br /><span style="font-size: small;">      <span style="color: #000080; font-weight: bold;">for</span>(<span style="color: #000080; font-weight: bold;">int </span>node : nodes)</span><br /><span style="font-size: small;">         visited[node] = <span style="color: #000080; font-weight: bold;">true</span>;</span><br /><span style="font-size: small;">      l.add(nodes);</span><br /><span style="font-size: small;">   }</span><br /><br /><span style="font-size: small;">   <span style="color: #000080; font-weight: bold;">int</span>[][] result = <span style="color: #000080; font-weight: bold;">new int</span>[l.size()][];</span><br /><span style="font-size: small;">   <span style="color: #000080; font-weight: bold;">int </span>i=<span style="color: #0000ff;">0</span>;</span><br /><span style="font-size: small;">   <span style="color: #000080; font-weight: bold;">for</span>(<span style="color: #000080; font-weight: bold;">int</span>[] component : l)</span><br /><span style="font-size: small;">      result[i++] = component;</span><br /><span style="font-size: small;">   <span style="color: #000080; font-weight: bold;">return </span>result;</span><br /><span style="font-size: small;">}</span></pre>
<p>Com este método podemos saber facilmente se um grafo é totalmente conectado (i.e., só tem uma componente):</p>
<pre style="background-color: #ffffff; color: #000000; font-family: 'Courier New'; margin-left: 30px;"><span style="font-size: small;"><span style="color: #000080; font-weight: bold;">public boolean </span>isConnected() {</span><br /><span style="font-size: small;">   <span style="color: #000080; font-weight: bold;">return </span>components().<span style="color: #660e7a; font-weight: bold;">length </span>== <span style="color: #0000ff;">1</span>;</span><br /><span style="font-size: small;">}</span></pre>
<p>Para experimentar este código resolvam o <a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=400">UVa459 - Graph Connectivity</a>.</p>
<p><strong>Componentes Fortes de Grafo</strong></p>
<p>A noção de componente que falámos na secção anterior fiz respeito a <a class="autolink" title="Grafos" href="https://moodle.ciencias.ulisboa.pt/mod/page/view.php?id=113913">grafos</a> não-orientados. Para <a class="autolink" title="Grafos" href="https://moodle.ciencias.ulisboa.pt/mod/page/view.php?id=113913">grafos</a> orientados (onde os arcos têm uma direcção), existe a noção de componente forte. Em inglês diz-se <em>strongly connected component</em> e abrevia-se normalmente por SCC. Uma SCC é um subconjunto de nós que, entre si, estão fortemente conectados, ie, há caminhos entre todos eles.</p>
<p>Na imagem seguinte observamos três SCC's:</p>
<p style="text-align: center;"><img src="imgs/graph_3scc.png" width="404" height="186" /></p>
<p>Reparem, por exemplo, que o nó b e c não pertence ao mesmo SCC dado que não existe um caminho do nó c para b.</p>
<p>Existem dois algoritmos tradicionais para resolver este problema, a versão de <a href="https://en.wikipedia.org/wiki/Kosaraju%27s_algorithm">Kosaraju</a> e a de <a href="https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm">Tarjan</a>. O algoritmo aqui implementado é a versão de Tarjan:</p>

<pre style="background-color: #ffffff; color: #000000; font-family: 'Courier New'; margin-left: 30px;"><span style="font-size: small;"><span style="color: #808080; font-style: italic;">/**<br /></span><span style="color: #808080; font-style: italic;"> * Find strong connected components (SCC) of a *directed* graph<br /></span><span style="color: #808080; font-style: italic;"> * For any pair of vertices u and v in a SCC, there is a path from u to v and vice versa<br /></span><span style="color: #808080; font-style: italic;"> * Cf. Halim book, pags. 133-4<br /></span><span style="color: #808080; font-style: italic;"> * Cf. https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm<br /></span><span style="color: #808080; font-style: italic;"> * </span><span style="color: #808080; font-weight: bold; font-style: italic;">@requires </span><span style="color: #808080; font-style: italic;">a directed graph<br /></span><span style="color: #808080; font-style: italic;"> * </span><span style="color: #808080; font-weight: bold; font-style: italic;">@complexity </span><span style="color: #808080; font-style: italic;">O(V </span>+ <span style="color: #808080; font-style: italic;">E)<br /></span><span style="color: #808080; font-style: italic;"> * </span><span style="color: #808080; font-weight: bold; font-style: italic;">@return </span><span style="color: #808080; font-style: italic;">An array of components (each component is an array of strongly connected nodes)<br /></span><span style="color: #808080; font-style: italic;"> */<br /></span><span style="color: #000080; font-weight: bold;">public int</span>[][] strongComponents() {</span><br /><span style="font-size: small;">   ArrayList&lt;<span style="color: #000080; font-weight: bold;">int</span>[]&gt; l = <span style="color: #000080; font-weight: bold;">new </span>ArrayList&lt;<span style="color: #000080; font-weight: bold;">int</span>[]&gt;();</span><br /><br /><span style="font-size: small;">   <span style="color: #660e7a; font-weight: bold;">SSC_Stack   </span>= <span style="color: #000080; font-weight: bold;">new </span>Stack&lt;Integer&gt;();</span><br /><span style="font-size: small;">   <span style="color: #660e7a; font-weight: bold;">SSC_OnStack </span>= <span style="color: #000080; font-weight: bold;">new boolean</span>[<span style="color: #660e7a; font-weight: bold;">size</span>];</span><br /><span style="font-size: small;">   <span style="color: #660e7a; font-weight: bold;">SSC_low     </span>= <span style="color: #000080; font-weight: bold;">new int</span>[<span style="color: #660e7a; font-weight: bold;">size</span>];</span><br /><span style="font-size: small;">   <span style="color: #660e7a; font-weight: bold;">SSC_index   </span>= <span style="color: #000080; font-weight: bold;">new int</span>[<span style="color: #660e7a; font-weight: bold;">size</span>];</span><br /><span style="font-size: small;">   <span style="color: #660e7a; font-weight: bold;">SSC_counter </span>= <span style="color: #0000ff;">0</span>;</span><br /><br /><span style="font-size: small;">   <span style="color: #000080; font-weight: bold;">for</span>(<span style="color: #000080; font-weight: bold;">int </span>i=<span style="color: #0000ff;">0</span>; i&lt;<span style="color: #660e7a; font-weight: bold;">size</span>; i++)</span><br /><span style="font-size: small;">      <span style="color: #660e7a; font-weight: bold;">SSC_index</span>[i] = <span style="color: #660e7a; font-weight: bold;">SSC_UNVISITED</span>;</span><br /><br /><span style="font-size: small;">   <span style="color: #000080; font-weight: bold;">for</span>(<span style="color: #000080; font-weight: bold;">int </span>i=<span style="color: #0000ff;">0</span>; i&lt;<span style="color: #660e7a; font-weight: bold;">size</span>; i++)</span><br /><span style="font-size: small;">      <span style="color: #000080; font-weight: bold;">if </span>(<span style="color: #660e7a; font-weight: bold;">SSC_index</span>[i] == <span style="color: #660e7a; font-weight: bold;">SSC_UNVISITED</span>) {</span><br /><span style="font-size: small;">         SSC(i);                       <span style="color: #808080; font-style: italic;">// process a connect set of nodes<br /></span><span style="color: #808080; font-style: italic;">         </span><span style="color: #000080; font-weight: bold;">int </span>k = <span style="color: #660e7a; font-weight: bold;">SSC_Stack</span>.size();</span><br /><span style="font-size: small;">         <span style="color: #000080; font-weight: bold;">while </span>(!<span style="color: #660e7a; font-weight: bold;">SSC_Stack</span>.isEmpty()) { <span style="color: #808080; font-style: italic;">// create each strong component<br /></span><span style="color: #808080; font-style: italic;">            </span>ArrayList&lt;Integer&gt; lSSC = <span style="color: #000080; font-weight: bold;">new </span>ArrayList&lt;Integer&gt;();</span><br /><span style="font-size: small;">            <span style="color: #000080; font-weight: bold;">do </span>{</span><br /><span style="font-size: small;">                <span style="color: #000080; font-weight: bold;">int </span>node = <span style="color: #660e7a; font-weight: bold;">SSC_Stack</span>.pop();</span><br /><span style="font-size: small;">                <span style="color: #660e7a; font-weight: bold;">SSC_OnStack</span>[node] = <span style="color: #000080; font-weight: bold;">false</span>;</span><br /><span style="font-size: small;">                lSSC.add(node);</span><br /><span style="font-size: small;">                k--;</span><br /><span style="font-size: small;">             } <span style="color: #000080; font-weight: bold;">while </span>(<span style="color: #660e7a; font-weight: bold;">SSC_low</span>[k]!=<span style="color: #660e7a; font-weight: bold;">SSC_index</span>[k]);</span><br /><span style="font-size: small;">            l.add(list2array(lSSC));</span><br /><span style="font-size: small;">         }</span><br /><span style="font-size: small;">      }</span><br /><br /><span style="font-size: small;">   <span style="color: #000080; font-weight: bold;">int</span>[][] result = <span style="color: #000080; font-weight: bold;">new int</span>[l.size()][];</span><br /><span style="font-size: small;">   <span style="color: #000080; font-weight: bold;">int </span>i = <span style="color: #0000ff;">0</span>;</span><br /><span style="font-size: small;">   <span style="color: #000080; font-weight: bold;">for</span>(<span style="color: #000080; font-weight: bold;">int</span>[] component : l)</span><br /><span style="font-size: small;">      result[i++] = component;</span><br /><span style="font-size: small;">   <span style="color: #000080; font-weight: bold;">return </span>result;</span><br /><span style="font-size: small;">}<br /><br /></span></pre>
<pre style="background-color: #ffffff; color: #000000; font-family: 'Courier New'; margin-left: 30px;"><span style="font-size: small;"><span style="color: #000080; font-weight: bold;">private final int      </span><span style="color: #660e7a; font-weight: bold;">SSC_UNVISITED </span>= -<span style="color: #0000ff;">1</span>;</span><br /><span style="font-size: small;"><span style="color: #000080; font-weight: bold;">private int            </span><span style="color: #660e7a; font-weight: bold;">SSC_counter</span>;</span><br /><span style="font-size: small;"><span style="color: #000080; font-weight: bold;">private </span>Stack&lt;Integer&gt; <span style="color: #660e7a; font-weight: bold;">SSC_Stack</span>;</span><br /><span style="font-size: small;"><span style="color: #000080; font-weight: bold;">private boolean</span>[]      <span style="color: #660e7a; font-weight: bold;">SSC_OnStack</span>;</span><br /><span style="font-size: small;"><span style="color: #000080; font-weight: bold;">private int</span>[]          <span style="color: #660e7a; font-weight: bold;">SSC_low</span>, <span style="color: #660e7a; font-weight: bold;">SSC_index</span>;</span><br /><br /><span style="font-size: small;"><span style="color: #000080; font-weight: bold;">private void </span>SSC(<span style="color: #000080; font-weight: bold;">int </span>node) {</span><br /><br /><span style="font-size: small;">   <span style="color: #808080; font-style: italic;">// Set the depth index for 'node' to the smallest unused index<br /></span><span style="color: #808080; font-style: italic;">   </span><span style="color: #660e7a; font-weight: bold;">SSC_low</span>[node] = <span style="color: #660e7a; font-weight: bold;">SSC_index</span>[node] = <span style="color: #660e7a; font-weight: bold;">SSC_counter</span>++;</span><br /><span style="font-size: small;">   <span style="color: #660e7a; font-weight: bold;">SSC_Stack</span>.push(node);</span><br /><span style="font-size: small;">   <span style="color: #660e7a; font-weight: bold;">SSC_OnStack</span>[node] = <span style="color: #000080; font-weight: bold;">true</span>;</span><br /><br /><span style="font-size: small;">   <span style="color: #000080; font-weight: bold;">for </span>(<span style="color: #000080; font-weight: bold;">int </span>succ : sucessors(node))     <span style="color: #808080; font-style: italic;">// Consider successors of node<br /></span><span style="color: #808080; font-style: italic;">   </span><span style="color: #000080; font-weight: bold;">if </span>(<span style="color: #660e7a; font-weight: bold;">SSC_index</span>[succ] == <span style="color: #660e7a; font-weight: bold;">SSC_UNVISITED</span>) {</span><br /><span style="font-size: small;">      SSC(succ);</span><br /><span style="font-size: small;">      <span style="color: #660e7a; font-weight: bold;">SSC_low</span>[node] = Math.<span style="font-style: italic;">min</span>(<span style="color: #660e7a; font-weight: bold;">SSC_low</span>[node], <span style="color: #660e7a; font-weight: bold;">SSC_low</span>[succ]);</span><br /><span style="font-size: small;">   } <span style="color: #000080; font-weight: bold;">else if </span>(<span style="color: #660e7a; font-weight: bold;">SSC_OnStack</span>[succ])</span><br /><span style="font-size: small;">      <span style="color: #660e7a; font-weight: bold;">SSC_low</span>[node] = Math.<span style="font-style: italic;">min</span>(<span style="color: #660e7a; font-weight: bold;">SSC_low</span>[node], <span style="color: #660e7a; font-weight: bold;">SSC_index</span>[succ]);</span><br /><span style="font-size: small;">}</span></pre>
<p>Experimentem resolver o <a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=2938">UVa11838 - Come and Go</a> com este algoritmo.</p>
<p>Outros problemas:</p>
<ul>
<li><a href="https://uva.onlinejudge.org/index.php?option=onlinejudge&amp;page=show_problem&amp;problem=183">UVa 247 - Calling Circles</a></li>
<li><a href="https://uva.onlinejudge.org/index.php?option=onlinejudge&amp;page=show_problem&amp;problem=2499">UVa 11504 - Dominos</a></li>
<li><a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=2756">UVa 11709 - Trust Groups</a></li>
</ul>

<div class="modified">Last modified: Wednesday, 21 June 2017, 10:45 AM</div>


</body>
</html>