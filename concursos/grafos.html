<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=yes">
  <meta name="description" content="How to use graphs">
  <title>Grafos</title>
</head>

<body>

<h1 style="text-align: center;">Grafos</h1>
<center><span style="font-size: small;"><em>João Pedro Neto</em></span></center>

<p>Os grafos são estruturas muito usadas na Matemática e na Informática dado a sua grande expressividade para modelar diferentes problemas.Como consequência dessa expressividade, existem muitos algoritmos que respondem a problemas diferentes. Não é de admirar, por isso, que tenham uma presença muito marcada nos concursos de programação.</p>

<h4>Introdução</h4>

<p>Definição (informal): um grafo é uma estrutura constituída por <strong>vértices</strong> (também designados por <strong>nós</strong>) e por <strong>arestas</strong> (ou <strong>arcos)</strong> que ligam pares de vértices. Em inglês são designados respectivamente por <strong>vertices</strong> and <strong>edges</strong>.</p>
<p>Uma forma de classificar grafos é se as arestas possuem direcção. Se sim, são <strong>grafos orientados</strong> (<strong>directed graphs</strong>). Caso contrário são <strong>grafos não orientados</strong> (<strong>undirected graphs</strong>).</p>

<center>
<table border="0">
<tbody>
<tr>
<td><img style="display: block; margin-left: auto; margin-right: auto;" src="imgs/directed-graph.png" width="290" height="181" /></td>
<td><img src="imgs/undirected-graph.png" width="282" height="179" /></td>
</tr>
</tbody>
</table>
</center>

<p>Dentro dos grafos orientados, se não existir um caminho entre vértices que dê uma volta completa, falamos de um grafo orientado acíclico (em inglês, <strong>directed acyclic graph</strong>, DAG). O exemplo acima não é um DAG dado que existe o caminho ACDBA que produz um ciclo.</p>
<p>As árvores podem ser vistas como grafos orientados especiais, onde cada par de vértices possui apenas um caminho possível.</p>
<p>Os grafos podem ter cada aresta associada a um número a que se chama <strong>peso</strong> (em inglês, <strong>weight</strong>).</p>
<p>Mais informações <a href="https://pt.wikipedia.org/wiki/Teoria_dos_grafos">aqui</a>.</p>

<h4>Representação em Memória</h4>
<p>As duas formas mais comuns de representar um grafo são por listas de adjacências e por matriz de adjacências.</p>
<p>Na <strong>lista de adjacências</strong> os vértices são representados num vector de listas. Cada índice do vector, ou seja, cada vértice possui uma lista com referências para os seus vizinhos. Por exemplo:</p>
<p style="text-align: center;"><img src="imgs/graph-adjacency-list-representation.png" width="404" height="259" /></p>
<p>Uma alternativa é usar uma <em>hash table</em> para armazenar as repectivas listas, usando o nome do vértice como chave.</p>
<p>Esta representação é útil quando lidamos com <strong>grafos esparsos</strong>, i.e., grafos com muitos nós mas poucas ligações, dado que a memória gasta é proporcional ao número de arestas existentes.</p>
<p>Na matriz de adjacências as ligações são representadas por uma matriz que em cada posição (i, j) representa uma aresta do vértice i para o vértice j do grafo por um número diferente de zero. Aqui vamos definir que se dois nós não estão ligados por uma aresta, o seu valor na matriz é zero.</p>
<p style="text-align: center;"><img src="imgs/graph-matrix-representation.png" width="426" height="177" /></p>
<p>Esta representação gasta mais memória independentemente do número de arestas. Se o grafo tem n nós, a matriz necessita de n<sup>2</sup> posições. Por outro lado, hanvedo espaço disponível para usar esta representação, o acesso à aresta é bastante mais rápido nesta representação.</p>
<p>Em Java é possível criar grafos com milhares de nós. O servidor do UVa disponibiliza memória para grafos entre 5000 e 10000 nós, o que nos garante que a maior parte dos problemas pode ser abordado desta forma.</p>
<p></p>
<h4>A classe GraphMatrix</h4>
<p>A classe que iremos usar permite usar duas representações diferentes, a matriz de adjacências  e a lista de adjacências para matrizes esparsas. Ela está preparada também para representar grafos orientados e não orientados. </p>
<p>O seu início é o seguinte:</p>
<pre style="background-color: #ffffff; color: #000000; font-family: 'Courier New'; font-size: 9,0pt;"><span style="font-size: small;"><span style="color: #000080; font-weight: bold;">class </span>Graph {</span><br /><br /><span style="font-size: small;">   <span style="color: #000080; font-weight: bold;">public static final boolean </span><span style="color: #660e7a; font-weight: bold; font-style: italic;">DIRECT   </span>= <span style="color: #000080; font-weight: bold;">true</span>,</span><br /><span style="font-size: small;">                             <span style="color: #660e7a; font-weight: bold; font-style: italic;">UNDIRECT </span>= !<span style="color: #660e7a; font-weight: bold; font-style: italic;">DIRECT</span>;</span><br /><br /><span style="font-size: small;">   <span style="color: #000080; font-weight: bold;">public static final boolean </span><span style="color: #660e7a; font-weight: bold; font-style: italic;">SPARSE </span>= <span style="color: #000080; font-weight: bold;">true</span>,</span><br /><span style="font-size: small;">                             <span style="color: #660e7a; font-weight: bold; font-style: italic;">NOTSPARSE </span>= !<span style="color: #660e7a; font-weight: bold; font-style: italic;">SPARSE</span>;</span><br /><br /><span style="font-size: small;">   <span style="color: #000080; font-weight: bold;">private boolean </span><span style="color: #660e7a; font-weight: bold;">isSparse</span>;    <span style="color: #808080; font-style: italic;">// is the graph using a sparse representation?<br /></span><span style="color: #808080; font-style: italic;">   </span><span style="color: #000080; font-weight: bold;">private boolean </span><span style="color: #660e7a; font-weight: bold;">isDirected</span>;  <span style="color: #808080; font-style: italic;">// is the graph directed?<br /></span><span style="color: #808080; font-style: italic;">   </span><span style="color: #000080; font-weight: bold;">private int     </span><span style="color: #660e7a; font-weight: bold;">size</span>;        <span style="color: #808080; font-style: italic;">// number of nodes<br /></span><span style="color: #808080; font-style: italic;"><br /></span><span style="color: #808080; font-style: italic;">   // Non-sparse representation:<br /></span><span style="color: #808080; font-style: italic;">   //  A 2D array where rows and columns represent the nodes and<br /></span><span style="color: #808080; font-style: italic;">   //    each position represents the weight between nodes (zero means no connection)<br /></span><span style="color: #808080; font-style: italic;">   //  The graph will consist of V nodes and E edges (E &lt;= V^2)<br /></span><span style="color: #808080; font-style: italic;"><br /></span><span style="color: #808080; font-style: italic;">    </span><span style="color: #000080; font-weight: bold;">private int</span>[][] <span style="color: #660e7a; font-weight: bold;">graphMatrix</span>;</span><br /><br /><span style="font-size: small;">   <span style="color: #808080; font-style: italic;">// Sparse representation<br /></span><span style="color: #808080; font-style: italic;">   //  An array of hashmaps to represent sparse graphs<br /></span><span style="color: #808080; font-style: italic;">    //  The edge (i,j,w) will be added as graphList[i].put(j,w)<br /></span><span style="color: #808080; font-style: italic;">    <br /></span><span style="color: #808080; font-style: italic;">    </span><span style="color: #000080; font-weight: bold;">private </span>ArrayList&lt;HashMap&lt;Integer,Integer&gt;&gt; <span style="color: #660e7a; font-weight: bold;">graphList</span>; </span><br />    <br /><span style="font-size: small;">    <span style="color: #808080; font-style: italic;">/////////////////////////// BASIC METHODS ////////////////////////////////////<br /></span><span style="color: #808080; font-style: italic;"><br /></span><span style="color: #808080; font-style: italic;">    // by default we use a matrix to represent a graph, ie, a non-sparse representation<br /></span><span style="color: #808080; font-style: italic;">    </span><span style="color: #000080; font-weight: bold;">public </span>Graph(<span style="color: #000080; font-weight: bold;">int </span>nodes, <span style="color: #000080; font-weight: bold;">boolean </span>graphType) {</span><br /><span style="font-size: small;">       <span style="color: #660e7a; font-weight: bold;">size        </span>= nodes;</span><br /><span style="font-size: small;">       <span style="color: #660e7a; font-weight: bold;">isDirected  </span>= graphType;</span><br /><span style="font-size: small;">       <span style="color: #660e7a; font-weight: bold;">isSparse    </span>= <span style="color: #000080; font-weight: bold;">false</span>;</span><br /><span style="font-size: small;">       <span style="color: #660e7a; font-weight: bold;">graphMatrix </span>= <span style="color: #000080; font-weight: bold;">new int</span>[<span style="color: #660e7a; font-weight: bold;">size</span>][<span style="color: #660e7a; font-weight: bold;">size</span>];</span><br /><span style="font-size: small;">    }</span><br />    <br /><span style="font-size: small;">   <span style="color: #000080; font-weight: bold;">public </span>Graph(<span style="color: #000080; font-weight: bold;">int </span>nodes, <span style="color: #000080; font-weight: bold;">boolean </span>graphType, <span style="color: #000080; font-weight: bold;">boolean </span>sparse) {</span><br /><span style="font-size: small;">       <span style="color: #660e7a; font-weight: bold;">size        </span>= nodes;</span><br /><span style="font-size: small;">       <span style="color: #660e7a; font-weight: bold;">isDirected  </span>= graphType;</span><br /><span style="font-size: small;">       <span style="color: #660e7a; font-weight: bold;">isSparse    </span>= sparse;</span><br /><br /><span style="font-size: small;">       <span style="color: #000080; font-weight: bold;">if </span>(<span style="color: #660e7a; font-weight: bold;">isSparse</span>) {</span><br /><span style="font-size: small;">          <span style="color: #660e7a; font-weight: bold;">graphList </span>= <span style="color: #000080; font-weight: bold;">new </span>ArrayList&lt;HashMap&lt;Integer,Integer&gt;&gt;(<span style="color: #660e7a; font-weight: bold;">size</span>);</span><br /><span style="font-size: small;">          <span style="color: #000080; font-weight: bold;">for </span>(<span style="color: #000080; font-weight: bold;">int </span>i=<span style="color: #0000ff;">0</span>; i&lt;<span style="color: #660e7a; font-weight: bold;">size</span>; i++)</span><br /><span style="font-size: small;">             <span style="color: #660e7a; font-weight: bold;">graphList</span>.add(i,<span style="color: #000080; font-weight: bold;">new </span>HashMap&lt;Integer,Integer&gt;());</span><br /><span style="font-size: small;">       } <span style="color: #000080; font-weight: bold;">else<br /></span><span style="color: #000080; font-weight: bold;">           </span><span style="color: #660e7a; font-weight: bold;">graphMatrix </span>= <span style="color: #000080; font-weight: bold;">new int</span>[<span style="color: #660e7a; font-weight: bold;">size</span>][<span style="color: #660e7a; font-weight: bold;">size</span>];</span><br /><span style="font-size: small;">    }</span></pre>
<p>Considerando a representação construímos os métodos básicos de inserção, remoção e consulta de arestas:</p>
<pre style="background-color: #ffffff; color: #000000; font-family: 'Courier New'; margin-left: 30px;"><span style="font-size: small;"><span style="color: #808080; font-style: italic;">/**<br /></span><span style="color: #808080; font-style: italic;"> * Add edge to graph<br /></span><span style="color: #808080; font-style: italic;"> */<br /></span><span style="color: #000080; font-weight: bold;">public void </span>add(<span style="color: #000080; font-weight: bold;">int </span>from, <span style="color: #000080; font-weight: bold;">int </span>to, <span style="color: #000080; font-weight: bold;">int </span>weight) {</span><br /><span style="font-size: small;">   <span style="color: #000080; font-weight: bold;">if </span>(<span style="color: #660e7a; font-weight: bold;">isSparse</span>) {</span><br /><span style="font-size: small;">      <span style="color: #660e7a; font-weight: bold;">graphList</span>.get(from).put(to, weight);</span><br /><span style="font-size: small;">       <span style="color: #000080; font-weight: bold;">if </span>(<span style="color: #660e7a; font-weight: bold;">isDirected </span>== <span style="color: #660e7a; font-weight: bold; font-style: italic;">UNDIRECT</span>)</span><br /><span style="font-size: small;">          <span style="color: #660e7a; font-weight: bold;">graphList</span>.get(to).put(from, weight);</span><br /><span style="font-size: small;">   } <span style="color: #000080; font-weight: bold;">else </span>{</span><br /><span style="font-size: small;">       <span style="color: #660e7a; font-weight: bold;">graphMatrix</span>[from][to] = weight;</span><br /><span style="font-size: small;">       <span style="color: #000080; font-weight: bold;">if </span>(<span style="color: #660e7a; font-weight: bold;">isDirected </span>== <span style="color: #660e7a; font-weight: bold; font-style: italic;">UNDIRECT</span>)</span><br /><span style="font-size: small;">          <span style="color: #660e7a; font-weight: bold;">graphMatrix</span>[to][from] = weight;</span><br /><span style="font-size: small;">   }</span><br /><span style="font-size: small;">}</span><br /><br /><span style="font-size: small;"><span style="color: #000080; font-weight: bold;">public void </span>add(<span style="color: #000080; font-weight: bold;">int </span>from, <span style="color: #000080; font-weight: bold;">int </span>to) { add(from, to, <span style="color: #0000ff;">1</span>); }</span><br /><br /><span style="font-size: small;"><span style="color: #808080; font-style: italic;">/**<br /></span><span style="color: #808080; font-style: italic;"> * Remove edge to graph<br /></span><span style="color: #808080; font-style: italic;"> */<br /></span><span style="color: #000080; font-weight: bold;">public void </span>remove(<span style="color: #000080; font-weight: bold;">int </span>from, <span style="color: #000080; font-weight: bold;">int </span>to) {  </span><br /><span style="font-size: small;">   <span style="color: #000080; font-weight: bold;">if </span>(<span style="color: #660e7a; font-weight: bold;">isSparse</span>) {</span><br /><span style="font-size: small;">      <span style="color: #660e7a; font-weight: bold;">graphList</span>.get(from).remove(to);</span><br /><span style="font-size: small;">      <span style="color: #000080; font-weight: bold;">if </span>(<span style="color: #660e7a; font-weight: bold;">isDirected </span>== <span style="color: #660e7a; font-weight: bold; font-style: italic;">UNDIRECT</span>)</span><br /><span style="font-size: small;">         <span style="color: #660e7a; font-weight: bold;">graphList</span>.get(to).remove(from);</span><br /><span style="font-size: small;">   } <span style="color: #000080; font-weight: bold;">else<br /></span><span style="color: #000080; font-weight: bold;">      </span>add(from, to, <span style="color: #0000ff;">0</span>);  <span style="color: #808080; font-style: italic;">// remove edge<br /></span>}</span><br /><br /><span style="font-size: small;"><span style="color: #000080; font-weight: bold;">public int </span>weight(<span style="color: #000080; font-weight: bold;">int </span>from, <span style="color: #000080; font-weight: bold;">int </span>to) {</span><br /><span style="font-size: small;">   <span style="color: #000080; font-weight: bold;">if </span>(<span style="color: #660e7a; font-weight: bold;">isSparse</span>) {</span><br /><span style="font-size: small;">      Integer w = <span style="color: #660e7a; font-weight: bold;">graphList</span>.get(from).get(to);</span><br /><span style="font-size: small;">      <span style="color: #000080; font-weight: bold;">return </span>w==<span style="color: #000080; font-weight: bold;">null </span>? <span style="color: #0000ff;">0 </span>: w;</span><br /><span style="font-size: small;">   } <span style="color: #000080; font-weight: bold;">else<br /></span><span style="color: #000080; font-weight: bold;">      return </span><span style="color: #660e7a; font-weight: bold;">graphMatrix</span>[from][to];</span><br /><span style="font-size: small;">}</span><br /><br /><span style="font-size: small;"><span style="color: #000080; font-weight: bold;">public int </span>size() {</span><br /><span style="font-size: small;">   <span style="color: #000080; font-weight: bold;">return </span><span style="color: #660e7a; font-weight: bold;">size</span>;</span><br /><span style="font-size: small;">}</span><br /><br /><span style="font-size: small;"><span style="color: #808080; font-style: italic;">/**<br /></span><span style="color: #808080; font-style: italic;"> * Remove all in-edges and out-edges from/into node<br /></span><span style="color: #808080; font-style: italic;"> */<br /></span><span style="color: #000080; font-weight: bold;">public void </span>isolate(<span style="color: #000080; font-weight: bold;">int </span>node) {</span><br /><span style="font-size: small;">   <span style="color: #000080; font-weight: bold;">if </span>(<span style="color: #660e7a; font-weight: bold;">isSparse</span>) {</span><br /><span style="font-size: small;">      <span style="color: #660e7a; font-weight: bold;">graphList</span>.set(node, <span style="color: #000080; font-weight: bold;">new </span>HashMap&lt;Integer,Integer&gt;()); <span style="color: #808080; font-style: italic;">// remove out-edges<br /></span><span style="color: #808080; font-style: italic;">      </span><span style="color: #000080; font-weight: bold;">for </span>(<span style="color: #000080; font-weight: bold;">int </span>i=<span style="color: #0000ff;">0</span>; i&lt;<span style="color: #660e7a; font-weight: bold;">size</span>; i++)</span><br /><span style="font-size: small;">         <span style="color: #660e7a; font-weight: bold;">graphList</span>.get(i).remove(node);             <span style="color: #808080; font-style: italic;">// remove in-edges (slow)<br /></span><span style="color: #808080; font-style: italic;">   </span>} <span style="color: #000080; font-weight: bold;">else </span>{</span><br /><span style="font-size: small;">       <span style="color: #000080; font-weight: bold;">if </span>(<span style="color: #660e7a; font-weight: bold;">isDirected</span>==<span style="color: #660e7a; font-weight: bold; font-style: italic;">DIRECT</span>)</span><br /><span style="font-size: small;">          <span style="color: #660e7a; font-weight: bold;">graphMatrix</span>[node] = <span style="color: #000080; font-weight: bold;">new int</span>[<span style="color: #660e7a; font-weight: bold;">size</span>];</span><br /><span style="font-size: small;">       <span style="color: #000080; font-weight: bold;">for</span>(<span style="color: #000080; font-weight: bold;">int </span>i=<span style="color: #0000ff;">0</span>;i&lt;<span style="color: #660e7a; font-weight: bold;">size</span>;i++)</span><br /><span style="font-size: small;">          remove(i, node);</span><br /><span style="font-size: small;">   }</span><br /><span style="font-size: small;">}</span></pre>
<p>Podemos igualmente construir outros métodos auxiliares que serão úteis em futuros algoritmos. Leiam os javadocs e o código.</p>
<pre style="background-color: #ffffff; color: #000000; font-family: 'Courier New';"><span style="font-size: small;">   <span style="color: #808080; font-style: italic;">/**<br /></span><span style="color: #808080; font-style: italic;">    * </span><span style="color: #808080; font-weight: bold; font-style: italic;">@param </span><span style="color: #3d3d3d; font-weight: bold; font-style: italic;">node </span><span style="color: #808080; font-style: italic;">The node which successors we need<br /></span><span style="color: #808080; font-style: italic;">    * </span><span style="color: #808080; font-weight: bold; font-style: italic;">@requires </span><span style="color: #808080; font-style: italic;">a directed graph<br /></span><span style="color: #808080; font-style: italic;">    * </span><span style="color: #808080; font-weight: bold; font-style: italic;">@return </span><span style="color: #808080; font-style: italic;">an array with the indexes of the node's successors<br /></span><span style="color: #808080; font-style: italic;">    */<br /></span><span style="color: #808080; font-style: italic;">   </span><span style="color: #000080; font-weight: bold;">public int</span>[] sucessors(<span style="color: #000080; font-weight: bold;">int </span>node) {</span><br /><span style="font-size: small;">       ArrayList&lt;Integer&gt; l = <span style="color: #000080; font-weight: bold;">new </span>ArrayList&lt;Integer&gt;();</span><br /><br /><span style="font-size: small;">       <span style="color: #000080; font-weight: bold;">if </span>(<span style="color: #660e7a; font-weight: bold;">isSparse</span>) {</span><br /><span style="font-size: small;">          <span style="color: #000080; font-weight: bold;">for </span>(Integer successor : <span style="color: #660e7a; font-weight: bold;">graphList</span>.get(node).keySet())</span><br /><span style="font-size: small;">             l.add(successor);</span><br /><span style="font-size: small;">       } <span style="color: #000080; font-weight: bold;">else </span>{</span><br /><span style="font-size: small;">           <span style="color: #000080; font-weight: bold;">for</span>(<span style="color: #000080; font-weight: bold;">int </span>i=<span style="color: #0000ff;">0</span>; i&lt;<span style="color: #660e7a; font-weight: bold;">size</span>; i++)</span><br /><span style="font-size: small;">              <span style="color: #000080; font-weight: bold;">if </span>(weight(node,i) != <span style="color: #0000ff;">0</span>)</span><br /><span style="font-size: small;">                 l.add(i);</span><br /><span style="font-size: small;">       }</span><br /><br /><span style="font-size: small;">       <span style="color: #000080; font-weight: bold;">return </span>list2array(l);</span><br /><span style="font-size: small;">   }</span><br />   <br /><span style="font-size: small;">   <span style="color: #808080; font-style: italic;">/**<br /></span><span style="color: #808080; font-style: italic;">    * </span><span style="color: #808080; font-weight: bold; font-style: italic;">@param </span><span style="color: #3d3d3d; font-weight: bold; font-style: italic;">node </span><span style="color: #808080; font-style: italic;">The node which predecessors we need<br /></span><span style="color: #808080; font-style: italic;">    * </span><span style="color: #808080; font-weight: bold; font-style: italic;">@requires </span><span style="color: #808080; font-style: italic;">a directed graph<br /></span><span style="color: #808080; font-style: italic;">    * </span><span style="color: #808080; font-weight: bold; font-style: italic;">@return </span><span style="color: #808080; font-style: italic;">an array with the indexes of the node's predecessors<br /></span><span style="color: #808080; font-style: italic;">    */<br /></span><span style="color: #808080; font-style: italic;">   </span><span style="color: #000080; font-weight: bold;">public int</span>[] predecessors(<span style="color: #000080; font-weight: bold;">int </span>node) {</span><br /><span style="font-size: small;">       ArrayList&lt;Integer&gt; l = <span style="color: #000080; font-weight: bold;">new </span>ArrayList&lt;Integer&gt;();</span><br /><br /><span style="font-size: small;">       <span style="color: #000080; font-weight: bold;">if </span>(<span style="color: #660e7a; font-weight: bold;">isSparse</span>) {</span><br /><span style="font-size: small;">          <span style="color: #000080; font-weight: bold;">for </span>(<span style="color: #000080; font-weight: bold;">int </span>i=<span style="color: #0000ff;">0</span>; i&lt;<span style="color: #660e7a; font-weight: bold;">size</span>; i++) { <span style="color: #808080; font-style: italic;">// slow<br /></span><span style="color: #808080; font-style: italic;">             </span>Integer weight = <span style="color: #660e7a; font-weight: bold;">graphList</span>.get(i).get(node);</span><br /><span style="font-size: small;">             <span style="color: #000080; font-weight: bold;">if </span>(weight != <span style="color: #000080; font-weight: bold;">null</span>)</span><br /><span style="font-size: small;">                l.add(i);</span><br /><span style="font-size: small;">          }</span><br /><span style="font-size: small;">       } <span style="color: #000080; font-weight: bold;">else </span>{</span><br /><span style="font-size: small;">           <span style="color: #000080; font-weight: bold;">for</span>(<span style="color: #000080; font-weight: bold;">int </span>i=<span style="color: #0000ff;">0</span>; i&lt;<span style="color: #660e7a; font-weight: bold;">size</span>; i++)</span><br /><span style="font-size: small;">              <span style="color: #000080; font-weight: bold;">if </span>(weight(i,node) != <span style="color: #0000ff;">0</span>)</span><br /><span style="font-size: small;">                 l.add(i);</span><br /><span style="font-size: small;">       }</span><br /><br /><span style="font-size: small;">       <span style="color: #000080; font-weight: bold;">return </span>list2array(l);</span><br /><span style="font-size: small;">   }    </span><br /><br /><span style="font-size: small;">   <span style="color: #808080; font-style: italic;">/**<br /></span><span style="color: #808080; font-style: italic;">    * Make a copy of this<br /></span><span style="color: #808080; font-style: italic;">    * </span><span style="color: #808080; font-weight: bold; font-style: italic;">@return </span><span style="color: #808080; font-style: italic;">the reference to the copy<br /></span><span style="color: #808080; font-style: italic;">    */<br /></span><span style="color: #808080; font-style: italic;">   </span><span style="color: #808000;">@SuppressWarnings</span>(<span style="color: #008000; font-weight: bold;">"unchecked"</span>)</span><br /><span style="font-size: small;"><span style="color: #000080; font-weight: bold;">   public </span>Graph copy() {</span><br /><br /><span style="font-size: small;">       Graph cp = <span style="color: #000080; font-weight: bold;">new </span>Graph(<span style="color: #000080; font-weight: bold;">this</span>.<span style="color: #660e7a; font-weight: bold;">size</span>, <span style="color: #000080; font-weight: bold;">this</span>.<span style="color: #660e7a; font-weight: bold;">isDirected</span>, <span style="color: #000080; font-weight: bold;">this</span>.<span style="color: #660e7a; font-weight: bold;">isSparse</span>);</span><br /><br /><span style="font-size: small;">       <span style="color: #000080; font-weight: bold;">if </span>(<span style="color: #660e7a; font-weight: bold;">isSparse</span>) {</span><br /><span style="font-size: small;">           <span style="color: #000080; font-weight: bold;">for</span>(<span style="color: #000080; font-weight: bold;">int </span>i=<span style="color: #0000ff;">0</span>;i&lt;cp.<span style="color: #660e7a; font-weight: bold;">size</span>;i++)</span><br /><span style="font-size: small;">              cp.<span style="color: #660e7a; font-weight: bold;">graphList</span>.set(i,</span><br /><span style="font-size: small;">                    (HashMap&lt;Integer,Integer&gt;)<span style="color: #000080; font-weight: bold;">this</span>.<span style="color: #660e7a; font-weight: bold;">graphList</span>.get(i).clone());</span><br /><span style="font-size: small;">       } <span style="color: #000080; font-weight: bold;">else </span>{</span><br /><span style="font-size: small;">           <span style="color: #000080; font-weight: bold;">for</span>(<span style="color: #000080; font-weight: bold;">int </span>i=<span style="color: #0000ff;">0</span>;i&lt;cp.<span style="color: #660e7a; font-weight: bold;">size</span>;i++)</span><br /><span style="font-size: small;">              cp.<span style="color: #660e7a; font-weight: bold;">graphMatrix</span>[i] = <span style="color: #000080; font-weight: bold;">this</span>.<span style="color: #660e7a; font-weight: bold;">graphMatrix</span>[i].clone();</span><br /><span style="font-size: small;">       }</span><br /><br /><span style="font-size: small;">       <span style="color: #000080; font-weight: bold;">return </span>cp;</span><br /><span style="font-size: small;">   }</span><br />   <br /><span style="font-size: small;">   <span style="color: #000080; font-weight: bold;">public </span>String toString() {</span><br /><span style="font-size: small;">       StringBuffer sb = <span style="color: #000080; font-weight: bold;">new </span>StringBuffer();</span><br /><br /><span style="font-size: small;">       <span style="color: #000080; font-weight: bold;">if </span>(<span style="color: #660e7a; font-weight: bold;">isSparse</span>) {</span><br /><span style="font-size: small;">           <span style="color: #000080; font-weight: bold;">for</span>(<span style="color: #000080; font-weight: bold;">int </span>i=<span style="color: #0000ff;">0</span>; i&lt;<span style="color: #660e7a; font-weight: bold;">size</span>; i++)</span><br /><span style="font-size: small;">              <span style="color: #000080; font-weight: bold;">for </span>(Integer j : <span style="color: #660e7a; font-weight: bold;">graphList</span>.get(i).keySet()) {</span><br /><span style="font-size: small;">                 <span style="color: #000080; font-weight: bold;">int </span>weight = <span style="color: #660e7a; font-weight: bold;">graphList</span>.get(i).get(j);</span><br /><span style="font-size: small;">                  <span style="color: #000080; font-weight: bold;">if </span>(weight!=<span style="color: #0000ff;">0</span>)</span><br /><span style="font-size: small;">                     <span style="color: #000080; font-weight: bold;">if </span>(weight==<span style="color: #0000ff;">1</span>)</span><br /><span style="font-size: small;">                        sb.append(i+<span style="color: #008000; font-weight: bold;">"-&gt;"</span>+j+<span style="color: #008000; font-weight: bold;">" "</span>); <span style="color: #808080; font-style: italic;">// don't show weights 1<br /></span><span style="color: #808080; font-style: italic;">                     </span><span style="color: #000080; font-weight: bold;">else<br /></span><span style="color: #000080; font-weight: bold;">                        </span>sb.append(i+<span style="color: #008000; font-weight: bold;">"-{"</span>+weight+<span style="color: #008000; font-weight: bold;">"}-&gt;"</span>+j+<span style="color: #008000; font-weight: bold;">" "</span>);</span><br /><span style="font-size: small;">              }</span><br /><span style="font-size: small;">       } <span style="color: #000080; font-weight: bold;">else </span>{</span><br /><span style="font-size: small;">           <span style="color: #000080; font-weight: bold;">for</span>(<span style="color: #000080; font-weight: bold;">int </span>i=<span style="color: #0000ff;">0</span>; i&lt;<span style="color: #660e7a; font-weight: bold;">size</span>; i++)</span><br /><span style="font-size: small;">               <span style="color: #000080; font-weight: bold;">for</span>(<span style="color: #000080; font-weight: bold;">int </span>j=<span style="color: #0000ff;">0</span>; j&lt;<span style="color: #660e7a; font-weight: bold;">size</span>; j++)</span><br /><span style="font-size: small;">                  <span style="color: #000080; font-weight: bold;">if </span>(weight(i,j)!=<span style="color: #0000ff;">0</span>)</span><br /><span style="font-size: small;">                     <span style="color: #000080; font-weight: bold;">if </span>(weight(i,j)==<span style="color: #0000ff;">1</span>)</span><br /><span style="font-size: small;">                        sb.append(i+<span style="color: #008000; font-weight: bold;">"-&gt;"</span>+j+<span style="color: #008000; font-weight: bold;">" "</span>); <span style="color: #808080; font-style: italic;">// don't show weights 1<br /></span><span style="color: #808080; font-style: italic;">                     </span><span style="color: #000080; font-weight: bold;">else<br /></span><span style="color: #000080; font-weight: bold;">                        </span>sb.append(i+<span style="color: #008000; font-weight: bold;">"-{"</span>+weight(i,j)+<span style="color: #008000; font-weight: bold;">"}-&gt;"</span>+j+<span style="color: #008000; font-weight: bold;">" "</span>);</span><br /><span style="font-size: small;">       }</span><br /><br /><span style="font-size: small;">       <span style="color: #000080; font-weight: bold;">return </span>sb.toString();</span><br /><span style="font-size: small;">   }</span><br />   <br /><span style="font-size: small;">   <span style="color: #000080; font-weight: bold;">private int</span>[] list2array(ArrayList&lt;Integer&gt; list) { </span><br /><span style="font-size: small;">       <span style="color: #000080; font-weight: bold;">int</span>[] array = <span style="color: #000080; font-weight: bold;">new int</span>[list.size()];</span><br /><span style="font-size: small;">       <span style="color: #000080; font-weight: bold;">int </span>index=<span style="color: #0000ff;">0</span>;</span><br /><br /><span style="font-size: small;">       <span style="color: #000080; font-weight: bold;">for</span>(<span style="color: #000080; font-weight: bold;">int </span>elem : list)</span><br /><span style="font-size: small;">          array[index++] = elem;</span><br /><span style="font-size: small;">       <span style="color: #000080; font-weight: bold;">return </span>array;</span><br /><span style="font-size: small;">   }</span></pre>
<p>Será a partir desta estrutura que iremos incluir algoritmos sobre grafos e que nos ajudarão a resolver diversos tipos de problemas.</p>

<div class="modified">Last modified: Wednesday, 21 June 2017, 9:37 AM</div>

</body>
</html>