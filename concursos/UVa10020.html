<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=yes">
  <meta name="description" content="Greedy Algorithms">
  <title>UVa 10020 - Algoritmos Gananciosos</title>
</head>

<body>

<h1 style="text-align: center;">UVa 10020: Minimal Coverage</h1>
<center><span style="font-size: small;"><em>João Pedro Neto</em></span></center>

<p>Leiam o <a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=961">enunciado do problema</a>.</p>

<p>Este é um exemplo direto de um problema designado por <em>interval coverage</em>. Dado um intervalo inicial [A,B] e um conjunto de intervalos [L_i, R_i], encontrar o número mínimo destes que cubram a totalidade do intervalo inicial.</p>

<p>Este problema clássico tem uma solução <em>greedy</em> que é possível de reutilizar noutros locais dado ser um tema que aparece em vários problemas de programação competitiva.</p>

<p>Para tal precisamos primeiro ordenar os intervalos da seguinte forma: primeiro ordenados de forma <em>crescente</em> pelos valores L_i, e nos seus valores iguais, ordenados de forma <em>decrescente</em> pelos R_i. Por exemplo, [0,2] &lt; [0,1] &lt; [1,2].</p>

<p>Na nossa solução vamos representar estes intervalos [L_i, R_i] como objectos da classe privada <span style="font-size: small; font-family: courier new,courier,monospace;">Pair</span></p>

<pre style="background-color: #ffffff; color: #000000; font-family: 'Courier New'; margin-left: 30px;"><span style="font-size: small;"><span style="color: #000080; font-weight: bold;"><br />public class </span>UVa_10020_MinimalCoverage {<br /></span><br /><br /><span style="font-size: small;">    <span style="color: #000080; font-weight: bold;">private static class </span>Pair <span style="color: #000080; font-weight: bold;">implements </span>Comparable&lt;Pair&gt;{</span><br /><span style="font-size: small;">        <span style="color: #000080; font-weight: bold;">int </span><span style="color: #660e7a; font-weight: bold;">l</span>, <span style="color: #660e7a; font-weight: bold;">r</span>;</span><br /><span style="font-size: small;">        Pair(<span style="color: #000080; font-weight: bold;">int </span>l, <span style="color: #000080; font-weight: bold;">int </span>r) {</span><br /><span style="font-size: small;">            <span style="color: #000080; font-weight: bold;">this</span>.<span style="color: #660e7a; font-weight: bold;">l</span>=l; <span style="color: #000080; font-weight: bold;">this</span>.<span style="color: #660e7a; font-weight: bold;">r</span>=r;</span><br /><span style="font-size: small;">        }</span><br /><span style="font-size: small;">        <span style="color: #000080; font-weight: bold;">public </span>String toString(){</span><br /><span style="font-size: small;">            <span style="color: #000080; font-weight: bold;">return </span><span style="color: #008000; font-weight: bold;">"[" </span>+ <span style="color: #660e7a; font-weight: bold;">l </span>+ <span style="color: #008000; font-weight: bold;">"," </span>+ <span style="color: #660e7a; font-weight: bold;">r </span>+ <span style="color: #008000; font-weight: bold;">"]"</span>;</span><br /><span style="font-size: small;">        }</span><br /><br /><span style="font-size: small;">        <span style="color: #808080; font-style: italic;">// eg: [0,2] &lt; [0,1] &lt; [1,2]<br /></span><span style="color: #808080; font-style: italic;">        </span><span style="color: #808000;">@Override<br /></span><span style="color: #808000;">        </span><span style="color: #000080; font-weight: bold;">public int </span>compareTo(Pair p2) {</span><br /><span style="font-size: small;">            <span style="color: #000080; font-weight: bold;">if </span>(<span style="color: #000080; font-weight: bold;">this</span>.<span style="color: #660e7a; font-weight: bold;">l</span>&gt;p2.<span style="color: #660e7a; font-weight: bold;">l</span>) <span style="color: #000080; font-weight: bold;">return </span><span style="color: #0000ff;">1</span>;</span><br /><span style="font-size: small;">            <span style="color: #000080; font-weight: bold;">if </span>(<span style="color: #000080; font-weight: bold;">this</span>.<span style="color: #660e7a; font-weight: bold;">l</span>&lt;p2.<span style="color: #660e7a; font-weight: bold;">l</span>) <span style="color: #000080; font-weight: bold;">return </span>-<span style="color: #0000ff;">1</span>;</span><br /><span style="font-size: small;">            <span style="color: #000080; font-weight: bold;">return this</span>.<span style="color: #660e7a; font-weight: bold;">r</span>&lt;p2.<span style="color: #660e7a; font-weight: bold;">r </span>? <span style="color: #0000ff;">1 </span>: -<span style="color: #0000ff;">1</span>;</span><br /><span style="font-size: small;">        }</span><br /><span style="font-size: small;">    }<br />...</span></pre>

<p>No nosso problema actual, o intervalo [A,B] tem o formato [0,M]. Logo, neste caso, temos de primeiro começar por um intervalo que comece antes ou no valor zero (se não houver intervalos nestas condições -- todos os intervalos são negativos -- não vamos ter solução).</p>

<p>A ideia é ir guardando o melhor intervalo que nos aparece correntemente, e que satisfaça ter o valor L_i à esquerda do valor desejado. Quando nos aparece um intervalo cujo valor R_i é maior, guardamos esse, dado que ainda é melhor que os intervalos encontrados até agora. Por exemplo, se temos o intervalo [-1,4] e aparece o [0,5], preferimos guardar este último dado que só precisamos cobrir o intervalo inicial a partir do zero.</p>

<p>Quando aparece um intervalo com um L_i que passa o valor desejado à esquerda, temos de guardar o melhor que encontramos até agora. Continuando o exemplo: se depois do [0,5] nos aparece um [2,7], temos de guardar o [0,5] dado que mais nenhum intervalo vai aparecer que cubra o 0 (lembrem-se que ordenámos os intervalos).</p>

<p>O novo intervalo pode ser interessante ou não. No caso do [2,7] ficamos com ele (até ver). Mas se nos aparecesse o [2,4], esse não nos interessava pois esses valores já estão incluídos no [0,5] que acabámos de guardar.</p>

<p>Vamos repetindo isto até que o último intervalo guardado tenha um R_i maior que M, ou que ocorra uma situação onde um dos valores que procuramos à esquerda ou à direita não possa ser satisfeito. Nesse segundo caso temos de informar que a instância do problema não tem solução.</p>

<p>Segue uma possível solução que utiliza este algoritmo (com bastantes comentários).</p>

<p>Como neste caso, cada instância do problema pode ter até 100 mil intervalos, não usamos o Scanner dado ser muito lento para ler muito <em>input</em> (cf. a página '<a href="https://moodle.ciencias.ulisboa.pt/mod/page/view.php?id=113888">Quando é necessário ler muito input</a>' onde está descrita a classe <span style="font-family: courier new,courier,monospace;">Reader</span> usada a seguir).</p>

<pre style="background-color: #ffffff; color: #000000; font-family: 'Courier New'; margin-left: 30px;"><span style="font-size: small;">    <span style="color: #000080; font-weight: bold;">public static void </span>main(String[] args) {<br /></span><br /><span style="font-size: small;">        <span style="color: #000080; font-weight: bold;">if </span>(!<span style="color: #000080; font-weight: bold;">new </span>Object(){}.getClass().getName().contains(<span style="color: #008000; font-weight: bold;">"Main"</span>))</span><br /><span style="font-size: small;">            <span style="color: #000080; font-weight: bold;">try </span>{   <span style="color: #808080; font-style: italic;">// redirect System.in and System.out to in/out text files<br /></span><span style="color: #808080; font-style: italic;">                </span>System.<span style="font-style: italic;">setIn </span>(<span style="color: #000080; font-weight: bold;">new </span>FileInputStream(<span style="color: #008000; font-weight: bold;">"data/uva10020.in.txt" </span>));</span><br /><span style="font-size: small;">                System.<span style="font-style: italic;">setOut</span>(<span style="color: #000080; font-weight: bold;">new </span>PrintStream(<span style="color: #008000; font-weight: bold;">"data/uva10020.out.txt"</span>) );</span><br /><span style="font-size: small;">            } <span style="color: #000080; font-weight: bold;">catch </span>(Exception e) {}</span><br /><span style="font-size: small;">        <span style="color: #808080; font-style: italic;">///////////////////////////////////////////////////////////////<br /></span><span style="color: #808080; font-style: italic;"><br /></span><span style="color: #808080; font-style: italic;">        </span><span style="color: #000080; font-weight: bold;">try </span>{</span><br /><br /><span style="font-size: small;">            Reader.<span style="font-style: italic;">init</span>( System.<span style="color: #660e7a; font-weight: bold; font-style: italic;">in </span>);</span><br /><br /><span style="font-size: small;">            <span style="color: #000080; font-weight: bold;">int </span>nCases = Reader.<span style="font-style: italic;">nextInt</span>();</span><br /><span style="font-size: small;">            <span style="color: #000080; font-weight: bold;">while </span>(nCases-- &gt; <span style="color: #0000ff;">0</span>) {</span><br /><br /><span style="font-size: small;">                <span style="color: #000080; font-weight: bold;">int </span>M = Reader.<span style="font-style: italic;">nextInt</span>(); <span style="color: #808080; font-style: italic;">// defining coverage interval [0,M]<br /></span><span style="color: #808080; font-style: italic;"><br /></span><span style="color: #808080; font-style: italic;">                </span>List&lt;Pair&gt; available = <span style="color: #000080; font-weight: bold;">new </span>LinkedList&lt;Pair&gt;(); <span style="color: #808080; font-style: italic;">// list of available intervals<br /></span><span style="color: #808080; font-style: italic;">                </span>List&lt;Pair&gt; coverage = <span style="color: #000080; font-weight: bold;">new </span>LinkedList&lt;Pair&gt;();  <span style="color: #808080; font-style: italic;">// list of minimal coverage intervals<br /></span><span style="color: #808080; font-style: italic;"><br /></span><span style="color: #808080; font-style: italic;">                </span><span style="color: #000080; font-weight: bold;">int </span>l, r;  <span style="color: #808080; font-style: italic;">// read &amp; keep pairs of available intervals until a 0 0 appears<br /></span><span style="color: #808080; font-style: italic;">                </span><span style="color: #000080; font-weight: bold;">do </span>{</span><br /><span style="font-size: small;">                    l = Reader.<span style="font-style: italic;">nextInt</span>();</span><br /><span style="font-size: small;">                    r = Reader.<span style="font-style: italic;">nextInt</span>();</span><br /><span style="font-size: small;">                    <span style="color: #000080; font-weight: bold;">if </span>(l != <span style="color: #0000ff;">0 </span>|| r != <span style="color: #0000ff;">0</span>)</span><br /><span style="font-size: small;">                        available.add(<span style="color: #000080; font-weight: bold;">new </span>Pair(l, r));</span><br /><span style="font-size: small;">                } <span style="color: #000080; font-weight: bold;">while </span>(l != <span style="color: #0000ff;">0 </span>|| r != <span style="color: #0000ff;">0</span>);</span><br /><br /><span style="font-size: small;">                available.sort((p1, p2) -&gt; p1.compareTo(p2));  <span style="color: #808080; font-style: italic;">// sort pairs for greedy algorithm<br /></span><span style="color: #808080; font-style: italic;"><br /></span><span style="color: #808080; font-style: italic;">                // greedy algorithm<br /></span><span style="color: #808080; font-style: italic;">                </span><span style="color: #000080; font-weight: bold;">int </span>need_left = <span style="color: #0000ff;">0</span>;                  <span style="color: #808080; font-style: italic;">// from where we still need to cover<br /></span><span style="color: #808080; font-style: italic;">                </span>Pair current_best = <span style="color: #000080; font-weight: bold;">new </span>Pair(<span style="color: #0000ff;">0</span>, <span style="color: #0000ff;">0</span>); <span style="color: #808080; font-style: italic;">// our best interval so far<br /></span><span style="color: #808080; font-style: italic;">                </span><span style="color: #000080; font-weight: bold;">boolean </span>have_current_best = <span style="color: #000080; font-weight: bold;">false</span>;  <span style="color: #808080; font-style: italic;">// have we a good interval?<br /></span><span style="color: #808080; font-style: italic;">                </span><span style="color: #000080; font-weight: bold;">boolean </span>not_feasible = <span style="color: #000080; font-weight: bold;">false</span>;       <span style="color: #808080; font-style: italic;">// is it unfeasible to cover [0,M]?<br /></span><span style="color: #808080; font-style: italic;"><br /></span><span style="color: #808080; font-style: italic;">                </span><span style="color: #000080; font-weight: bold;">for </span>(Pair p : available) {</span><br /><span style="font-size: small;">                    <span style="color: #000080; font-weight: bold;">if </span>(p.<span style="color: #660e7a; font-weight: bold;">l </span>&lt;= need_left) {           <span style="color: #808080; font-style: italic;">// if p has good left value<br /></span><span style="color: #808080; font-style: italic;">                        </span><span style="color: #000080; font-weight: bold;">if </span>(p.<span style="color: #660e7a; font-weight: bold;">r </span>&gt; current_best.<span style="color: #660e7a; font-weight: bold;">r</span>) {   <span style="color: #808080; font-style: italic;">//   and better right value that what we found so far<br /></span><span style="color: #808080; font-style: italic;">                            </span>current_best = p;         <span style="color: #808080; font-style: italic;">// let's keep it<br /></span><span style="color: #808080; font-style: italic;">                            </span>have_current_best = <span style="color: #000080; font-weight: bold;">true</span>; <span style="color: #808080; font-style: italic;">// &amp; flag it!<br /></span><span style="color: #808080; font-style: italic;">                        </span>}</span><br /><span style="font-size: small;">                    } <span style="color: #000080; font-weight: bold;">else </span>{</span><br /><span style="font-size: small;">                        <span style="color: #000080; font-weight: bold;">if </span>(have_current_best) {</span><br /><span style="font-size: small;">                            <span style="color: #808080; font-style: italic;">// we want to keep this one, nothing after this is going to be better<br /></span><span style="color: #808080; font-style: italic;">                            // (due to the previous pair ordering)<br /></span><span style="color: #808080; font-style: italic;">                            </span>coverage.add(current_best);</span><br /><span style="font-size: small;">                            <span style="color: #808080; font-style: italic;">// update requirements<br /></span><span style="color: #808080; font-style: italic;">                            </span>need_left = current_best.<span style="color: #660e7a; font-weight: bold;">r</span>; <span style="color: #808080; font-style: italic;">// we need to start looking from the current best right<br /></span><span style="color: #808080; font-style: italic;">                            </span>have_current_best = <span style="color: #000080; font-weight: bold;">false</span>;  <span style="color: #808080; font-style: italic;">// and we'll restart looking for good candidates<br /></span><span style="color: #808080; font-style: italic;">                            // ...unless<br /></span><span style="color: #808080; font-style: italic;">                            </span><span style="color: #000080; font-weight: bold;">if </span>(need_left &gt;= M)</span><br /><span style="font-size: small;">                                <span style="color: #000080; font-weight: bold;">break</span>;  <span style="color: #808080; font-style: italic;">// then, it's job done!<br /></span><span style="color: #808080; font-style: italic;">                        </span>}</span><br /><br /><span style="font-size: small;">                        <span style="color: #808080; font-style: italic;">// since we are looking for updated values, we need to recheck the current pair<br /></span><span style="color: #808080; font-style: italic;">                        </span><span style="color: #000080; font-weight: bold;">if </span>(p.<span style="color: #660e7a; font-weight: bold;">l </span>&lt;= need_left) {</span><br /><span style="font-size: small;">                            <span style="color: #000080; font-weight: bold;">if </span>(p.<span style="color: #660e7a; font-weight: bold;">r </span>&gt; current_best.<span style="color: #660e7a; font-weight: bold;">l</span>) {</span><br /><span style="font-size: small;">                                current_best = p;       <span style="color: #808080; font-style: italic;">// let's keep it<br /></span><span style="color: #808080; font-style: italic;">                                </span>have_current_best = <span style="color: #000080; font-weight: bold;">true</span>;</span><br /><span style="font-size: small;">                            }</span><br /><span style="font-size: small;">                        } <span style="color: #000080; font-weight: bold;">else </span>{</span><br /><span style="font-size: small;">                            <span style="color: #808080; font-style: italic;">// if the current's left value is higher that what we need, then we will <br /></span><span style="color: #808080; font-style: italic;">                            // <span style="font-size: small;"><span style="color: #808080; font-style: italic;">not be able to</span></span> satisfy the coverage, and must announce failure!<br /></span><span style="color: #808080; font-style: italic;">                            </span>not_feasible = <span style="color: #000080; font-weight: bold;">true</span>;</span><br /><span style="font-size: small;">                            <span style="color: #000080; font-weight: bold;">break</span>;</span><br /><span style="font-size: small;">                        }</span><br /><span style="font-size: small;">                    }</span><br /><span style="font-size: small;">                } <span style="color: #808080; font-style: italic;">// for<br /></span><span style="color: #808080; font-style: italic;"><br /></span><span style="color: #808080; font-style: italic;">                </span><span style="color: #000080; font-weight: bold;">if </span>(have_current_best) {</span><br /><span style="font-size: small;">                    coverage.add(current_best);</span><br /><span style="font-size: small;">                    <span style="color: #000080; font-weight: bold;">if </span>(current_best.<span style="color: #660e7a; font-weight: bold;">r </span>&lt; M)  <span style="color: #808080; font-style: italic;">// it might not be enough<br /></span><span style="color: #808080; font-style: italic;">                        </span>not_feasible = <span style="color: #000080; font-weight: bold;">true</span>;</span><br /><span style="font-size: small;">                }</span><br /><br /><span style="font-size: small;">                <span style="color: #000080; font-weight: bold;">if </span>(not_feasible) {</span><br /><span style="font-size: small;">                    System.<span style="color: #660e7a; font-weight: bold; font-style: italic;">out</span>.println(<span style="color: #0000ff;">0 </span>+ <span style="color: #008000; font-weight: bold;">"</span><span style="color: #000080; font-weight: bold;">\n</span><span style="color: #008000; font-weight: bold;">"</span>);</span><br /><span style="font-size: small;">                } <span style="color: #000080; font-weight: bold;">else </span>{</span><br /><span style="font-size: small;">                    System.<span style="color: #660e7a; font-weight: bold; font-style: italic;">out</span>.println(coverage.size());</span><br /><span style="font-size: small;">                    <span style="color: #000080; font-weight: bold;">for</span>(Pair p : coverage)</span><br /><span style="font-size: small;">                        System.<span style="color: #660e7a; font-weight: bold; font-style: italic;">out</span>.println(p.<span style="color: #660e7a; font-weight: bold;">l </span>+ <span style="color: #008000; font-weight: bold;">" " </span>+ p.<span style="color: #660e7a; font-weight: bold;">r</span>);</span><br /><span style="font-size: small;">                    <span style="color: #000080; font-weight: bold;">if </span>(nCases&gt;<span style="color: #0000ff;">0</span>)  <span style="color: #808080; font-style: italic;">// give extra newline except for the last case<br /></span><span style="color: #808080; font-style: italic;">                        </span>System.<span style="color: #660e7a; font-weight: bold; font-style: italic;">out</span>.println();</span><br /><span style="font-size: small;">                }</span><br /><span style="font-size: small;">            } <span style="color: #808080; font-style: italic;">// while<br /></span><span style="color: #808080; font-style: italic;"><br /></span><span style="color: #808080; font-style: italic;">        </span>} <span style="color: #000080; font-weight: bold;">catch </span>(Exception e) {};</span><br /><span style="font-size: small;">    }</span><br /><span style="font-size: small;">}</span></pre>
<p>Outros problemas UVa resolúveis via <em>interval converage</em>:</p>
<ul>
<li><a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=3634">UVa 1193 - Radar Installation</a></li>
<li><a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=1323">UVa 10382 - Watering Grass</a></li>
<li><a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=3743">UVa 12321 - Gas Station</a></li>
<li><a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=3836">UVa 12405 - Scarecrow</a></li>
</ul>
<p></p></div></div><div class="modified">Last modified: Friday, 10 February 2017, 12:14 PM</div></div>

</body>
</html>