<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=yes">
  <meta name="description" content="How to use graphs">
  <title>Flood Fill</title>
</head>

<body>

<h1 style="text-align: center;">Flood Fill</h1>
<center><span style="font-size: small;"><em>João Pedro Neto</em></span></center>

<p>O algoritmo de <em>flood fill</em> calcula a área relacionada a uma dada posição de uma matriz.</p>
<p>Normalmente o algoritmo necessita da posição, de uma cor inicial e de uma cor substituto. O que o algoritmo faz é trocar a cor inicialpela cor substituto de todas as posições conectadas à posição inicial que tenham essa cor inicial.</p>
<p>Este gif animado (via <a href="https://en.wikipedia.org/wiki/Flood_fill">wikipedia</a>) mostra a ideia geral (assume-se conectadas posições na ortogonal e na diagonal):</p>
<p style="text-align: center;"><img src="imgs/graph_flood_fill.gif" width="144" height="144" /></p>
<p>O algoritmo seguinte utiliza a representação matricial da class Graph para implementar o <em>flood fill</em>. Isto significa que não se deve interpretar o objecto grafo usado no flood-fill como um grafo mas apenas como uma matriz 2D.</p>
<p>Existem dois valores para os vectores dr[ ] e dc[ ] que correspondem a ter conexões apenas ortogonais (o que está comentado) ou conexões ortogonais e diagonais. Dependendo do problema, devem escolher os valores adequados.</p>
<pre style="background-color: #ffffff; color: #000000; font-family: 'Courier New'; margin-left: 30px;"><span style="font-size: small;">   <span style="color: #000080; font-weight: bold;">static int </span><span style="color: #660e7a; font-style: italic;">dr</span>[] = {<span style="color: #0000ff;">1</span>,<span style="color: #0000ff;">1</span>,<span style="color: #0000ff;">0</span>,-<span style="color: #0000ff;">1</span>,-<span style="color: #0000ff;">1</span>,-<span style="color: #0000ff;">1</span>, <span style="color: #0000ff;">0</span>, <span style="color: #0000ff;">1</span>}; <span style="color: #808080; font-style: italic;">// trick to explore an implicit 2D grid<br /></span><span style="color: #808080; font-style: italic;">   </span><span style="color: #000080; font-weight: bold;">static int </span><span style="color: #660e7a; font-style: italic;">dc</span>[] = {<span style="color: #0000ff;">0</span>,<span style="color: #0000ff;">1</span>,<span style="color: #0000ff;">1</span>, <span style="color: #0000ff;">1</span>, <span style="color: #0000ff;">0</span>,-<span style="color: #0000ff;">1</span>,-<span style="color: #0000ff;">1</span>,-<span style="color: #0000ff;">1</span>}; <span style="color: #808080; font-style: italic;">// S,SE,E,NE,N,NW,W,SW neighbors<br /></span><span style="color: #808080; font-style: italic;"><br /></span><span style="color: #808080; font-style: italic;">   //static int dr[] = {1,0,-1, 0}; // <br /></span><span style="color: #808080; font-style: italic;">   //static int dc[] = {0,1, 0,-1}; // S,E,N,W neighbors<br /></span><span style="color: #808080; font-style: italic;"><br /></span><span style="color: #808080; font-style: italic;">   /**<br /></span><span style="color: #808080; font-style: italic;">    * Use graph structure to simulate a 2D grid<br /></span><span style="color: #808080; font-style: italic;">    * Replaces the old color by the new considering all directions,<br /></span><span style="color: #808080; font-style: italic;">    * and returns the total number of replacements<br /></span><span style="color: #808080; font-style: italic;">    * </span><span style="color: #808080; font-weight: bold; font-style: italic;">@ensures </span><span style="color: #808080; font-style: italic;">a total chaotic graph if interpreted by default<br /></span><span style="color: #808080; font-style: italic;">    * </span><span style="color: #808080; font-weight: bold; font-style: italic;">@complexity </span><span style="color: #808080; font-style: italic;">O(V </span>+ <span style="color: #808080; font-style: italic;">E)<br /></span><span style="color: #808080; font-style: italic;">    * </span><span style="color: #808080; font-weight: bold; font-style: italic;">@throws </span><span style="color: #808080; font-style: italic;">Exception If representation is non-sparce (ie, it needs the adjacency matrix)<br /></span><span style="color: #808080; font-style: italic;">    */<br /></span><span style="color: #808080; font-style: italic;">   </span><span style="color: #000080; font-weight: bold;">public int </span>floodFill(<span style="color: #000080; font-weight: bold;">int </span>row, <span style="color: #000080; font-weight: bold;">int </span>col, <span style="color: #000080; font-weight: bold;">int </span>oldColor, <span style="color: #000080; font-weight: bold;">int </span>newColor) <span style="color: #000080; font-weight: bold;">throws </span>Exception {</span><br /><br /><span style="font-size: small;">     <span style="color: #000080; font-weight: bold;">if </span>(<span style="color: #660e7a; font-weight: bold;">isSparse</span>)</span><br /><span style="font-size: small;">        <span style="color: #000080; font-weight: bold;">throw new </span>Exception(<span style="color: #008000; font-weight: bold;">"Flood Fill only works on a non-sparce representation"</span>);</span><br /><br /><span style="font-size: small;">     <span style="color: #000080; font-weight: bold;">if </span>(row &lt; <span style="color: #0000ff;">0 </span>|| row &gt;= <span style="color: #660e7a; font-weight: bold;">size </span>|| col &lt; <span style="color: #0000ff;">0 </span>|| col &gt;= <span style="color: #660e7a; font-weight: bold;">size</span>)</span><br /><span style="font-size: small;">        <span style="color: #000080; font-weight: bold;">return </span><span style="color: #0000ff;">0</span>; <span style="color: #808080; font-style: italic;">// outside grid<br /></span><span style="color: #808080; font-style: italic;"><br /></span><span style="color: #808080; font-style: italic;">     </span><span style="color: #000080; font-weight: bold;">if </span>(<span style="color: #660e7a; font-weight: bold;">graphMatrix</span>[row][col] != oldColor)</span><br /><span style="font-size: small;">        <span style="color: #000080; font-weight: bold;">return </span><span style="color: #0000ff;">0</span>; <span style="color: #808080; font-style: italic;">// does not have old color<br /></span><span style="color: #808080; font-style: italic;"><br /></span><span style="color: #808080; font-style: italic;">     </span><span style="color: #660e7a; font-weight: bold;">graphMatrix</span>[row][col] = newColor;  <span style="color: #808080; font-style: italic;">// recolors vertex to avoid cycling<br /></span><span style="color: #808080; font-style: italic;">     </span><span style="color: #000080; font-weight: bold;">int </span>ans = <span style="color: #0000ff;">1</span>;                       <span style="color: #808080; font-style: italic;">// adds 1 because vertex (row, col) was replaced<br /></span><span style="color: #808080; font-style: italic;">     </span><span style="color: #000080; font-weight: bold;">for </span>(<span style="color: #000080; font-weight: bold;">int </span>d = <span style="color: #0000ff;">0</span>; d &lt; <span style="color: #0000ff;">8</span>; d++)</span><br /><span style="font-size: small;">        ans += floodFill(row + <span style="color: #660e7a; font-style: italic;">dr</span>[d], col + <span style="color: #660e7a; font-style: italic;">dc</span>[d], oldColor, newColor);</span><br /><span style="font-size: small;">     <span style="color: #000080; font-weight: bold;">return </span>ans; <span style="color: #808080; font-style: italic;">//<br /></span>  }</span></pre>
<p>Neste exemplo, o algoritmo é recursivo. Poder-se-ia implementar uma versão iterativa com uma <em>stack</em>. Fica como exercício para os curiosos.</p>
<p>Experimentem o problema <a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=410">UVa 469 - Wetlands of Florida</a>.</p>
<p>Outros problemas:</p>
<ul>
<li><a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=196">UVa 00260 - Il Gioco dell’X</a></li>
<li><a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=699">UVa 00758 - The Same Game</a></li>
<li><a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=723">UVa 00782 - Countour Painting</a></li>
</ul>

<div class="modified">Last modified: Wednesday, 21 June 2017, 11:34 AM</div>

</body>
</html>