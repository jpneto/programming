<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=yes">
  <meta name="description" content="How to use computational geometry">
  <title>Geometria Computacional - Polígonos</title>
</head>

<body>

<h1 style="text-align: center;">Geometria Computacional - Polígonos</h1>
<center><span style="font-size: small;"><em>João Pedro Neto</em></span></center>

<p>O polígono é outra figura geométrica que pode surgir em problemas. Neste contexto um polígono é uma sequência de segmentos de recta onde o último segmento liga-se ao primeiro. Cf. entrada da <a href="https://en.wikipedia.org/wiki/Polygon" target="_blank">wikipedia</a> para mais detalhes.</p>

<p>Aqui um polígono é definido pelos seus vértices, dados por objetos <code>Point</code>, onde o primeiro e o último ponto são os mesmos.</p>

<pre style="background-color: #ffffff; color: #000000; font-family: 'Courier New'; margin-left: 30px;"><span style="font-size: small;"><span style="color: #000080; font-weight: bold;">class </span>Polygon {</span><br /><br /><span style="font-size: small;">   <span style="color: #000080; font-weight: bold;">public </span>Point[] <span style="color: #660e7a; font-weight: bold;">vs</span>;</span><br /><br /><span style="font-size: small;">    <span style="color: #808080; font-style: italic;">//@pre: first and last points must be the same<br /></span><span style="color: #808080; font-style: italic;">   </span><span style="color: #000080; font-weight: bold;">public </span>Polygon(Point[] vs) {</span><br /><span style="font-size: small;">        <span style="color: #000080; font-weight: bold;">this</span>.<span style="color: #660e7a; font-weight: bold;">vs </span>= vs;</span><br /><span style="font-size: small;">    }<br />   ...<br /></span></pre>
<p>Vejamos as propriedades implementadas:</p>
<pre style="background-color: #ffffff; color: #000000; font-family: 'Courier New'; margin-left: 30px;"><span style="font-size: small;"><span style="color: #000080; font-weight: bold;">public double </span>perimeter() {</span><br /><span style="font-size: small;">    <span style="color: #000080; font-weight: bold;">double </span>result = <span style="color: #0000ff;">0.0</span>;</span><br /><span style="font-size: small;">    <span style="color: #000080; font-weight: bold;">for </span>(<span style="color: #000080; font-weight: bold;">int </span>i=<span style="color: #0000ff;">0</span>; i&lt;<span style="color: #660e7a; font-weight: bold;">vs</span>.<span style="color: #660e7a; font-weight: bold;">length</span>-<span style="color: #0000ff;">1</span>; i++)</span><br /><span style="font-size: small;">        result += <span style="color: #660e7a; font-weight: bold;">vs</span>[i].distance(<span style="color: #660e7a; font-weight: bold;">vs</span>[i+<span style="color: #0000ff;">1</span>]);</span><br /><span style="font-size: small;">    <span style="color: #000080; font-weight: bold;">return </span>result;</span><br /><span style="font-size: small;">}</span><br /><br /></pre>
<pre style="background-color: #ffffff; color: #000000; font-family: 'Courier New'; margin-left: 30px;"><span style="font-size: small;"><span style="color: #808080; font-style: italic;">// cf. https://en.wikipedia.org/wiki/Shoelace_formula</span></span><br /><span style="font-size: small;"><span style="color: #000080; font-weight: bold;">public double </span>area() { </span><br /><span style="font-size: small;"> <span style="color: #000080; font-weight: bold;">double </span>result = <span style="color: #0000ff;">0.0</span>, x1, y1, x2, y2;</span><br /><span style="font-size: small;"> <span style="color: #000080; font-weight: bold;">for </span>(<span style="color: #000080; font-weight: bold;">int </span>i = <span style="color: #0000ff;">0</span>; i&lt;<span style="color: #660e7a; font-weight: bold;">vs</span>.<span style="color: #660e7a; font-weight: bold;">length</span>-<span style="color: #0000ff;">1</span>; i++)</span><br /><span style="font-size: small;"> result += (<span style="color: #660e7a; font-weight: bold;">vs</span>[i].<span style="color: #660e7a; font-weight: bold;">x </span>* <span style="color: #660e7a; font-weight: bold;">vs</span>[i+<span style="color: #0000ff;">1</span>].<span style="color: #660e7a; font-weight: bold;">y</span>) - (<span style="color: #660e7a; font-weight: bold;">vs</span>[i+<span style="color: #0000ff;">1</span>].<span style="color: #660e7a; font-weight: bold;">x </span>* <span style="color: #660e7a; font-weight: bold;">vs</span>[i].<span style="color: #660e7a; font-weight: bold;">y</span>);</span><br /><span style="font-size: small;"> <span style="color: #000080; font-weight: bold;">return </span><span style="font-style: italic;">abs</span>(result) / <span style="color: #0000ff;">2.0</span>;</span><br /><span style="font-size: small;">}</span></pre>
<p>O próximo método verifica se o polígono é convexo, ie, se qualquer segmento criado por pontos internos ao polígono está sempre dentro do polígono. Isto pode calcular-se verificando se cada sequência de três pontos consecutivos forma sempre uma curva para o mesmo lado:</p>
<pre style="background-color: #ffffff; color: #000000; font-family: 'Courier New'; margin-left: 30px;"><span style="font-size: small;"><span style="color: #808080; font-style: italic;"></span></span><span style="font-size: small;"></span></pre>
<pre style="background-color: #ffffff; color: #000000; font-family: 'Courier New'; margin-left: 30px;"><span style="font-size: small;"><span style="color: #808080; font-style: italic;">// returns true if all three consecutive vertices form the same turns <br /></span><span style="color: #000080; font-weight: bold;">public boolean </span>isConvex() {</span><br /><span style="font-size: small;">    <span style="color: #000080; font-weight: bold;">int </span>sz = (<span style="color: #000080; font-weight: bold;">int</span>)<span style="color: #660e7a; font-weight: bold;">vs</span>.<span style="color: #660e7a; font-weight: bold;">length</span>;</span><br /><span style="font-size: small;">    <span style="color: #000080; font-weight: bold;">if </span>(sz &lt;= <span style="color: #0000ff;">3</span>) <span style="color: #000080; font-weight: bold;">return false</span>; <span style="color: #808080; font-style: italic;">// it's a point or a segment<br /></span><span style="color: #808080; font-style: italic;"><br /></span><span style="color: #808080; font-style: italic;">    </span><span style="color: #000080; font-weight: bold;">boolean </span>isLeft = Point.<span style="font-style: italic;">ccw</span>(<span style="color: #660e7a; font-weight: bold;">vs</span>[<span style="color: #0000ff;">0</span>], <span style="color: #660e7a; font-weight: bold;">vs</span>[<span style="color: #0000ff;">1</span>], <span style="color: #660e7a; font-weight: bold;">vs</span>[<span style="color: #0000ff;">2</span>]);</span><br /><span style="font-size: small;">    <span style="color: #000080; font-weight: bold;">for </span>(<span style="color: #000080; font-weight: bold;">int </span>i = <span style="color: #0000ff;">1</span>; i &lt; sz-<span style="color: #0000ff;">1</span>; i++)</span><br /><span style="font-size: small;">        <span style="color: #000080; font-weight: bold;">if </span>(Point.<span style="font-style: italic;">ccw</span>(<span style="color: #660e7a; font-weight: bold;">vs</span>[i], <span style="color: #660e7a; font-weight: bold;">vs</span>[i+<span style="color: #0000ff;">1</span>], <span style="color: #660e7a; font-weight: bold;">vs</span>[(i+<span style="color: #0000ff;">2</span>) == sz ? <span style="color: #0000ff;">1 </span>: i+<span style="color: #0000ff;">2</span>]) != isLeft)</span><br /><span style="font-size: small;">            <span style="color: #000080; font-weight: bold;">return false</span>;</span><br /><span style="font-size: small;">    <span style="color: #000080; font-weight: bold;">return true</span>;</span><br /><span style="font-size: small;">}</span></pre>
<p>O próximo método verifica se um ponto está dentro de um polígono (cf. Halim pg. 287):</p>
<pre style="background-color: #ffffff; color: #000000; font-family: 'Courier New'; font-size: 9,0pt;"><span style="color: #000080; font-weight: bold;"></span></pre>
<pre style="background-color: #ffffff; color: #000000; font-family: 'Courier New'; margin-left: 30px;"><span style="font-size: small;"><span style="color: #000080; font-weight: bold;">public boolean </span>inPolygon(Point p) {</span><br /><span style="font-size: small;">    <span style="color: #000080; font-weight: bold;">if </span>((<span style="color: #000080; font-weight: bold;">int</span>)<span style="color: #660e7a; font-weight: bold;">vs</span>.<span style="color: #660e7a; font-weight: bold;">length </span>== <span style="color: #0000ff;">0</span>) <span style="color: #000080; font-weight: bold;">return false</span>;</span><br /><span style="font-size: small;">    <span style="color: #000080; font-weight: bold;">double </span>sum = <span style="color: #0000ff;">0</span>;</span><br /><span style="font-size: small;">    <span style="color: #000080; font-weight: bold;">for </span>(<span style="color: #000080; font-weight: bold;">int </span>i = <span style="color: #0000ff;">0</span>; i &lt; <span style="color: #660e7a; font-weight: bold;">vs</span>.<span style="color: #660e7a; font-weight: bold;">length</span>-<span style="color: #0000ff;">1</span>; i++)</span><br /><span style="font-size: small;">        <span style="color: #000080; font-weight: bold;">if </span>(Point.<span style="font-style: italic;">ccw</span>(p, <span style="color: #660e7a; font-weight: bold;">vs</span>[i], <span style="color: #660e7a; font-weight: bold;">vs</span>[i + <span style="color: #0000ff;">1</span>]))</span><br /><span style="font-size: small;">            sum += Point.<span style="font-style: italic;">angle</span>(<span style="color: #660e7a; font-weight: bold;">vs</span>[i], p, <span style="color: #660e7a; font-weight: bold;">vs</span>[i + <span style="color: #0000ff;">1</span>]);    <span style="color: #808080; font-style: italic;">// left turn/ccw<br /></span><span style="color: #808080; font-style: italic;">        </span><span style="color: #000080; font-weight: bold;">else<br /></span><span style="color: #000080; font-weight: bold;">            </span>sum -= Point.<span style="font-style: italic;">angle</span>(<span style="color: #660e7a; font-weight: bold;">vs</span>[i], p, <span style="color: #660e7a; font-weight: bold;">vs</span>[i + <span style="color: #0000ff;">1</span>]);    <span style="color: #808080; font-style: italic;">// right turn/cw<br /></span><span style="color: #808080; font-style: italic;">    </span><span style="color: #000080; font-weight: bold;">return </span><span style="font-style: italic;">abs</span>(<span style="font-style: italic;">abs</span>(sum) - <span style="color: #0000ff;">2</span>*<span style="color: #660e7a; font-weight: bold; font-style: italic;">PI</span>) &lt; Point.<span style="color: #660e7a; font-weight: bold; font-style: italic;">EPSILON</span>;</span><br /><span style="font-size: small;">}</span></pre>
<p></p>
<p>Este método retorna o polígono resultante de cortar o polígono actual por uma linha (devolvemos o lado esquerdo) (cf. Halim, pg.288)</p>
<p style="text-align: center;"><img src="imgs/polygon_cut.jpg" width="478" height="147" /></p>
<pre style="background-color: #ffffff; color: #000000; font-family: 'Courier New'; margin-left: 30px;"><span style="font-size: small;"><span style="color: #808080; font-style: italic;">// cuts polygon along the line formed by points a b<br /></span><span style="color: #000080; font-weight: bold;">public </span>Polygon cutPolygon(Point a, Point b) {</span><br /><span style="font-size: small;">    ArrayList&lt;Point&gt; P = <span style="color: #000080; font-weight: bold;">new </span>ArrayList&lt;Point&gt;();</span><br /><br /><span style="font-size: small;">    <span style="color: #000080; font-weight: bold;">for </span>(<span style="color: #000080; font-weight: bold;">int </span>i = <span style="color: #0000ff;">0</span>; i &lt; <span style="color: #000080; font-weight: bold;">this</span>.<span style="color: #660e7a; font-weight: bold;">vs</span>.<span style="color: #660e7a; font-weight: bold;">length</span>; i++) {</span><br /><span style="font-size: small;">        <span style="color: #000080; font-weight: bold;">double </span>left1 = <span style="color: #000080; font-weight: bold;">new </span>Vector(a, b).cross(<span style="color: #000080; font-weight: bold;">new </span>Vector(a, <span style="color: #660e7a; font-weight: bold;">vs</span>[i])),</span><br /><span style="font-size: small;">               left2 = <span style="color: #0000ff;">0.0</span>;</span><br /><span style="font-size: small;">        <span style="color: #000080; font-weight: bold;">if </span>(i != <span style="color: #660e7a; font-weight: bold;">vs</span>.<span style="color: #660e7a; font-weight: bold;">length</span>-<span style="color: #0000ff;">1</span>)</span><br /><span style="font-size: small;">            left2 =  <span style="color: #000080; font-weight: bold;">new </span>Vector(a,b).cross(<span style="color: #000080; font-weight: bold;">new </span>Vector(a, <span style="color: #660e7a; font-weight: bold;">vs</span>[i+<span style="color: #0000ff;">1</span>]));</span><br /><span style="font-size: small;">        <span style="color: #000080; font-weight: bold;">if </span>(left1 &gt; -Point.<span style="color: #660e7a; font-weight: bold; font-style: italic;">EPSILON</span>)</span><br /><span style="font-size: small;">            P.add(<span style="color: #660e7a; font-weight: bold;">vs</span>[i]);                         <span style="color: #808080; font-style: italic;">// vs[i] is on the left of ab<br /></span><span style="color: #808080; font-style: italic;">        </span><span style="color: #000080; font-weight: bold;">if </span>(left1 * left2 &lt; -Point.<span style="color: #660e7a; font-weight: bold; font-style: italic;">EPSILON</span>)       <span style="color: #808080; font-style: italic;">// edge (vs[i], vs[i+1]) crosses line ab<br /></span><span style="color: #808080; font-style: italic;">            </span>P.add(Line.<span style="font-style: italic;">lineIntersectSegment</span>(<span style="color: #660e7a; font-weight: bold;">vs</span>[i], <span style="color: #660e7a; font-weight: bold;">vs</span>[i+<span style="color: #0000ff;">1</span>], a, b));</span><br /><span style="font-size: small;">    }</span><br /><span style="font-size: small;">    <span style="color: #000080; font-weight: bold;">if </span>(!P.isEmpty() &amp;&amp; !(P.get(<span style="color: #0000ff;">0</span>).equals(P.get(P.size()-<span style="color: #0000ff;">1</span>))))</span><br /><span style="font-size: small;">        P.add(P.get(<span style="color: #0000ff;">0</span>));                          <span style="color: #808080; font-style: italic;">// make Polygon's first point = last point<br /></span><span style="color: #808080; font-style: italic;">    </span><span style="color: #000080; font-weight: bold;">return new </span>Polygon(P.toArray(<span style="color: #000080; font-weight: bold;">new </span>Point[<span style="color: #0000ff;">0</span>]));  <span style="color: #808080; font-style: italic;">// toArray() needs to know what type of array<br /></span>}</span></pre>
<p>Finalmente, um algoritmo muito usado que é o <a href="https://en.wikipedia.org/wiki/Convex_hull" target="_blank"><em>Convex Hull</em></a>. A ideia é encontrar o polígono com menor perímetro que inclua um dado conjunto de pontos:</p>
<p style="text-align: center;"><img src="imgs/polygon_convex_hull.jpg" width="568" height="212" /></p>
<p>Este algoritmo é explicado nas páginas 289-291 do livro do Halim:</p>
<pre style="background-color: #ffffff; color: #000000; font-family: 'Courier New'; margin-left: 30px;"><span style="font-size: small;"><span style="color: #808080; font-style: italic;">// used in convex hull<br /></span><span style="color: #000080; font-weight: bold;">private static int </span>comparePoints(Point p, Point q) {</span><br /><span style="font-size: small;">    <span style="color: #000080; font-weight: bold;">if </span>(<span style="font-style: italic;">abs</span>(p.<span style="color: #660e7a; font-weight: bold;">x </span>- q.<span style="color: #660e7a; font-weight: bold;">x</span>) &gt; Point.<span style="color: #660e7a; font-weight: bold; font-style: italic;">EPSILON</span>)       <span style="color: #808080; font-style: italic;">// useful to sort...<br /></span><span style="color: #808080; font-style: italic;">        </span><span style="color: #000080; font-weight: bold;">return </span>(<span style="color: #000080; font-weight: bold;">int</span>)<span style="font-style: italic;">ceil</span>(p.<span style="color: #660e7a; font-weight: bold;">x </span>- q.<span style="color: #660e7a; font-weight: bold;">x</span>);          <span style="color: #808080; font-style: italic;">// ...first by x-coordinate<br /></span><span style="color: #808080; font-style: italic;">    </span><span style="color: #000080; font-weight: bold;">else if </span>(<span style="font-style: italic;">abs</span>(p.<span style="color: #660e7a; font-weight: bold;">y </span>- q.<span style="color: #660e7a; font-weight: bold;">y</span>) &gt; Point.<span style="color: #660e7a; font-weight: bold; font-style: italic;">EPSILON</span>)</span><br /><span style="font-size: small;">        <span style="color: #000080; font-weight: bold;">return </span>(<span style="color: #000080; font-weight: bold;">int</span>)<span style="font-style: italic;">ceil</span>(p.<span style="color: #660e7a; font-weight: bold;">y </span>- q.<span style="color: #660e7a; font-weight: bold;">y</span>);          <span style="color: #808080; font-style: italic;">// ... and second by y-coordinate<br /></span><span style="color: #808080; font-style: italic;">    </span><span style="color: #000080; font-weight: bold;">return </span><span style="color: #0000ff;">0</span>;</span><br /><span style="font-size: small;">}</span><br /><br /><span style="font-size: small;">Point <span style="color: #660e7a; font-weight: bold;">pivot </span>= <span style="color: #000080; font-weight: bold;">new </span>Point(<span style="color: #0000ff;">0</span>,<span style="color: #0000ff;">0</span>);  <span style="color: #808080; font-style: italic;">// used in convex hull<br /></span><span style="color: #808080; font-style: italic;"><br /></span>Polygon convexHull(List&lt;Point&gt; P) {</span><br /><span style="font-size: small;">    <span style="color: #000080; font-weight: bold;">int </span>i, j, n = (<span style="color: #000080; font-weight: bold;">int</span>)P.size();</span><br /><br /><span style="font-size: small;">    <span style="color: #000080; font-weight: bold;">if </span>(n &lt;= <span style="color: #0000ff;">3</span>) {</span><br /><span style="font-size: small;">        <span style="color: #000080; font-weight: bold;">if </span>(<span style="font-style: italic;">comparePoints</span>(P.get(<span style="color: #0000ff;">0</span>), P.get(n-<span style="color: #0000ff;">1</span>)) != <span style="color: #0000ff;">0</span>)</span><br /><span style="font-size: small;">            P.add(P.get(<span style="color: #0000ff;">0</span>));                        <span style="color: #808080; font-style: italic;">// safeguard from corner case<br /></span><span style="color: #808080; font-style: italic;">        </span><span style="color: #000080; font-weight: bold;">return new </span>Polygon((Point[])P.toArray());   <span style="color: #808080; font-style: italic;">// special case, the convex hull is P itself<br /></span><span style="color: #808080; font-style: italic;">    </span>}</span><br /><br /><span style="font-size: small;">    <span style="color: #808080; font-style: italic;">// first, find P0 = point with lowest Y and if tie: rightmost X<br /></span><span style="color: #808080; font-style: italic;">    </span><span style="color: #000080; font-weight: bold;">int </span>P0 = <span style="color: #0000ff;">0</span>;</span><br /><span style="font-size: small;">    <span style="color: #000080; font-weight: bold;">for </span>(i = <span style="color: #0000ff;">1</span>; i &lt; n; i++)</span><br /><span style="font-size: small;">        <span style="color: #000080; font-weight: bold;">if </span>(P.get(i).<span style="color: #660e7a; font-weight: bold;">y  </span>&lt; P.get(P0).<span style="color: #660e7a; font-weight: bold;">y </span>||</span><br /><span style="font-size: small;">                (P.get(i).<span style="color: #660e7a; font-weight: bold;">y </span>== P.get(P0).<span style="color: #660e7a; font-weight: bold;">y </span>&amp;&amp; P.get(i).<span style="color: #660e7a; font-weight: bold;">x </span>&gt; P.get(P0).<span style="color: #660e7a; font-weight: bold;">x</span>))</span><br /><span style="font-size: small;">            P0 = i;</span><br /><br /><span style="font-size: small;">    Point temp = P.get(<span style="color: #0000ff;">0</span>); P.set(<span style="color: #0000ff;">0</span>, P.get(P0)); P.set(P0 ,temp);   <span style="color: #808080; font-style: italic;">// swap P[P0] with P[0]<br /></span><span style="color: #808080; font-style: italic;"><br /></span><span style="color: #808080; font-style: italic;">    // second, sort points by angle w.r.t. P0<br /></span><span style="color: #808080; font-style: italic;">    </span><span style="color: #660e7a; font-weight: bold;">pivot </span>= P.get(<span style="color: #0000ff;">0</span>);                               <span style="color: #808080; font-style: italic;">// use this attribute variable as reference<br /></span><span style="color: #808080; font-style: italic;">    </span>Collections.<span style="font-style: italic;">sort</span>(P, <span style="color: #000080; font-weight: bold;">new </span>Comparator&lt;Point&gt;(){</span><br /><span style="font-size: small;">        <span style="color: #000080; font-weight: bold;">public int </span>compare(Point a, Point b) {      <span style="color: #808080; font-style: italic;">// angle-sorting function<br /></span><span style="color: #808080; font-style: italic;">            </span><span style="color: #000080; font-weight: bold;">if </span>(Point.<span style="font-style: italic;">collinear</span>(<span style="color: #660e7a; font-weight: bold;">pivot</span>, a, b))</span><br /><span style="font-size: small;">                <span style="color: #000080; font-weight: bold;">return </span><span style="color: #660e7a; font-weight: bold;">pivot</span>.distance(a) &lt; <span style="color: #660e7a; font-weight: bold;">pivot</span>.distance(b) ? -<span style="color: #0000ff;">1 </span>: <span style="color: #0000ff;">1</span>;   <span style="color: #808080; font-style: italic;">// which one is closer?<br /></span><span style="color: #808080; font-style: italic;">            </span><span style="color: #000080; font-weight: bold;">double </span>d1x = a.<span style="color: #660e7a; font-weight: bold;">x </span>- <span style="color: #660e7a; font-weight: bold;">pivot</span>.<span style="color: #660e7a; font-weight: bold;">x</span>, d1y = a.<span style="color: #660e7a; font-weight: bold;">y </span>- <span style="color: #660e7a; font-weight: bold;">pivot</span>.<span style="color: #660e7a; font-weight: bold;">y</span>;</span><br /><span style="font-size: small;">            <span style="color: #000080; font-weight: bold;">double </span>d2x = b.<span style="color: #660e7a; font-weight: bold;">x </span>- <span style="color: #660e7a; font-weight: bold;">pivot</span>.<span style="color: #660e7a; font-weight: bold;">x</span>, d2y = b.<span style="color: #660e7a; font-weight: bold;">y </span>- <span style="color: #660e7a; font-weight: bold;">pivot</span>.<span style="color: #660e7a; font-weight: bold;">y</span>;</span><br /><span style="font-size: small;">            <span style="color: #000080; font-weight: bold;">return </span>(<span style="font-style: italic;">atan2</span>(d1y, d1x) - <span style="font-style: italic;">atan2</span>(d2y, d2x)) &lt; <span style="color: #0000ff;">0 </span>? -<span style="color: #0000ff;">1 </span>: <span style="color: #0000ff;">1</span>;</span><br /><span style="font-size: small;">        }</span><br /><span style="font-size: small;">    });</span><br /><br /><span style="font-size: small;">    <span style="color: #808080; font-style: italic;">// third, the ccw tests<br /></span><span style="color: #808080; font-style: italic;">    </span>List&lt;Point&gt; S = <span style="color: #000080; font-weight: bold;">new </span>ArrayList&lt;Point&gt;();</span><br /><span style="font-size: small;">    S.add(P.get(n-<span style="color: #0000ff;">1</span>));</span><br /><span style="font-size: small;">    S.add(P.get(<span style="color: #0000ff;">0</span>));</span><br /><span style="font-size: small;">    S.add(P.get(<span style="color: #0000ff;">1</span>));  <span style="color: #808080; font-style: italic;">// initial S<br /></span><span style="color: #808080; font-style: italic;"><br /></span><span style="color: #808080; font-style: italic;">    </span>i = <span style="color: #0000ff;">2</span>;            <span style="color: #808080; font-style: italic;">// then, we check the rest<br /></span><span style="color: #808080; font-style: italic;">    </span><span style="color: #000080; font-weight: bold;">while </span>(i &lt; n) {   <span style="color: #808080; font-style: italic;">// note: n must be &gt;= 3 for this method to work<br /></span><span style="color: #808080; font-style: italic;">        </span>j = S.size() - <span style="color: #0000ff;">1</span>;</span><br /><span style="font-size: small;">        <span style="color: #000080; font-weight: bold;">if </span>(Point.<span style="font-style: italic;">ccw</span>(S.get(j-<span style="color: #0000ff;">1</span>), S.get(j), P.get(i)))</span><br /><span style="font-size: small;">            S.add(P.get(i++));       <span style="color: #808080; font-style: italic;">// left turn, accept<br /></span><span style="color: #808080; font-style: italic;">        </span><span style="color: #000080; font-weight: bold;">else<br /></span><span style="color: #000080; font-weight: bold;">            </span>S.remove(S.size() - <span style="color: #0000ff;">1</span>);  <span style="color: #808080; font-style: italic;">// or pop the top of S until we have a left turn<br /></span><span style="color: #808080; font-style: italic;">    </span>}</span><br /><span style="font-size: small;">    <span style="color: #000080; font-weight: bold;">return new </span>Polygon(S.toArray(<span style="color: #000080; font-weight: bold;">new </span>Point[<span style="color: #0000ff;">0</span>]));</span><br /><span style="font-size: small;">}</span></pre>
<p>A complexidade deste algoritmo é O(n log h), onde n é o número de pontos, e h os vértices do polígono resultante.</p>
<p></p>
<hr />
<p>Problemas UVa sugeridos:</p>
<ul>
<li><a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=45" target="_blank">UVa 00109 - Scud Busters</a></li>
<li><a href="https://uva.onlinejudge.org/index.php?option=onlinejudge&amp;page=show_problem&amp;problem=575" target="_blank">UVa 00634 - Polygon</a></li>
<li><a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=622" target="_blank">UVa 00681 - Convex Hull Finding</a></li>
<li><a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=3552" target="_blank">UVa 01111 - Trash Removal</a></li>
<li><a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=1593" target="_blank">UVa 10652 - Board Wrapping</a></li>
<li><a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=2232" target="_blank">UVa 11265 - The Sultan’s Problem</a></li>
</ul></div></div><div class="modified">Last modified: Monday, 27 February 2017, 9:17 AM</div>

</body>
</html>