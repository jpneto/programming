<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=yes">
  <meta name="description" content="Dynamic Programming">
  <title>Programação Dinâmica</title>
</head>

<body>

<h1 style="text-align: center;">Programação Dinâmica</h1>
<center><span style="font-size: small;"><em>João Pedro Neto</em></span></center>

<p><strong>O que é a Programação Dinâmica?</strong></p>
<p>A <strong>programação dinâmica</strong> (em inglês, <em>dynamic programming</em>, ou apenas DP) é uma técnica de análise de problemas, de cariz recursivo, que divide a resolução de um problema em subproblemas mais simples, armazenando as sub-soluções já encontradas para acelerar as seguintes. É uma técnica que sacrifica memória para ter ganhos de desempenho.</p>
<p>O guardar de sub-soluções designa-se <em><a href="https://en.wikipedia.org/wiki/Memoization">memoization</a>.</em> Costuma ser usado um vector ou matriz -- respectivamente para problemas com 1 ou 2 argumentos -- se as soluções podem ser indexadas. Noutros casos pode usar-se uma <em>hash table</em>.</p>
<p>Vejamos um exemplo básico com a sequência de Fibonacci.</p>
<p>A resolução directa é usando a própria definição recursiva:</p>
<pre class="SourceCode" style="margin-left: 30px;"><span style="font-size: small; font-family: courier new, courier, monospace;"><b>public</b> long fib(int n) {</span><br /><span style="font-size: small; font-family: courier new, courier, monospace;">  <strong>if</strong> (n==0 || n== 1)</span><br /><span style="font-size: small; font-family: courier new, courier, monospace;">    <strong>return</strong> 1;</span><br /><br /><span style="font-size: small; font-family: courier new, courier, monospace;">  <b>return</b> fib(n-2) + fib(n-1);</span><br /><span style="font-size: small; font-family: courier new, courier, monospace;">}</span></pre>
<p>Esta versão tem complexidade exponencial.</p>
<p>Isto ocorre porque estamos a repetir a resolução de imensos sub-problemas. Por exemplo, fib(5) e fib(4) precisam ambos de calcular fib(3).</p>
<p>Mas isto é evitável se guardarmos essas sub-soluções. Se o fizermos conseguimos uma solução de complexidade linear.</p>
<p>O seguinte código usa um vector chamado <span style="font-family: 'courier new', courier, monospace;">sols</span> para guardar sub-soluções. A escolha de um vector é apropriada dado que este problema apenas tem uma dimensão -- <span style="font-family: 'courier new', courier, monospace;">fib(n)</span> -- e pode ser indexada pelo <span style="font-family: 'courier new', courier, monospace;">n</span>:</p>
<pre style="margin-left: 30px;"><span style="font-size: small; font-family: courier new, courier, monospace;"><strong>private</strong> <strong>final</strong> int UNKNOWN = -1;    // usamos um valor que não pode ser solução</span><br /><br /><span style="font-size: small; font-family: courier new, courier, monospace;"><strong>public</strong> long fib(int n) {</span><br /><span style="font-size: small; font-family: courier new, courier, monospace;">  long[] sols = <strong>new</strong> long[n+1];</span><br /><br /><span style="font-size: small; font-family: courier new, courier, monospace;">  sols[0] = sols[1] = 1;        // no início, só se conhecem os casos base<br /></span><br /><span style="font-size: small; font-family: courier new, courier, monospace;">  <strong>for</strong>(int i=2; i&lt;=n; i++)</span><br /><span style="font-size: small; font-family: courier new, courier, monospace;">    sols[i] = UNKNOWN;      </span><br /><br /><span style="font-size: small; font-family: courier new, courier, monospace;">  <strong>return</strong> fib(sols, n);</span><br /><span style="font-size: small; font-family: courier new, courier, monospace;">}</span><br /><br /><span style="font-size: small; font-family: courier new, courier, monospace;"><strong>public</strong> long fib(long[] sols, int n) {</span><br /><span style="font-size: small; font-family: courier new, courier, monospace;">  <strong>if</strong> (sols[n] == UNKNOWN)</span><br /><span style="font-size: small; font-family: courier new, courier, monospace;">    sols[n] = fib(sols, n-2) + fib(sols, n-1);</span><br /><br /><span style="font-size: small; font-family: courier new, courier, monospace;">  <strong>return</strong> sols[n];</span><br /><span style="font-size: small; font-family: courier new, courier, monospace;">}</span></pre>
<hr />
<p>Até aqui, isto é apenas memorização, como referido nas aulas de AED.</p>
<p>O que realmente distingue a programação dinâmica é usar outras propriedades (que nem todos os problemas possuem, infelizmente): as sub-soluções que são respostas de sub-problemas têm de (a) fazer parte da solução do problema, e (b) os sub-problemas partilham sub-sub-problemas. Se isto se verificar, podemos ter ganhos muito grandes de desempenho.</p>
<p>Vejamos um exemplo clássico: o problema do <em>Knapsack</em> (apresentado na página 107 do livro do Halim).</p>
<p>Em português é conhecido pelo <strong>problema da mochila</strong> e citando a wikipedia:</p>
<p style="margin-left: 30px;"><span>O </span><b>problema da mochila</b><span> (em </span><a href="https://pt.wikipedia.org/wiki/L%C3%ADngua_inglesa" title="Língua inglesa">inglês</a><span>, </span><i>Knapsack problem</i><span>) é um problema de </span><a href="https://pt.wikipedia.org/wiki/Optimiza%C3%A7%C3%A3o_combinat%C3%B3ria" title="Optimização combinatória" class="mw-redirect">optimização combinatória</a><span>. O nome dá-se devido ao modelo de uma situação em que é necessário preencher uma mochila com [items] de diferentes pesos e valores. O objetivo é que se preencha a mochila com o maior valor possível, não ultrapassando o peso máximo.</span></p>
<p>Consideremos, por exemplo, os seguintes valores de <em>input</em>:</p>
<pre><span style="font-family: courier new, courier, monospace; font-size: small;">24     A capacidade da mochila é de 24 Kg</span><br /><span style="font-family: courier new, courier, monospace; font-size: small;">7      Existem 7 items</span><br /><span style="font-family: courier new, courier, monospace; font-size: small;">13  5   item 1 vale 13 unidades e pesa 5 Kg</span><br /><span style="font-family: courier new, courier, monospace; font-size: small;">30 10   item 2 vale 30 unidades e pesa 10 Kg</span><br /><span style="font-family: courier new, courier, monospace; font-size: small;">15  6   etc.</span><br /><span style="font-family: courier new, courier, monospace; font-size: small;">12  2</span><br /><span style="font-family: courier new, courier, monospace; font-size: small;">36 19</span><br /><span style="font-family: courier new, courier, monospace; font-size: small;"> 5  1</span><br /><span style="font-family: courier new, courier, monospace; font-size: small;">12  2</span></pre>
<p>Por exemplo, se escolhermos o 1º e 5º item, obtemos um valor total de 49 unidades para 24 Kg. Mas é possível fazer melhor!</p>
<p>Vamos designar a capacidade por C. Entre os n items, o i-ésimo item por P_i, com valor V_i e peso W_i.</p>
<p>Seja o resultado dado por</p>
<pre><span style="font-family: courier new, courier, monospace; font-size: small;">total( conjunto dos items, capacidade ) = total( {P_1, P_2, ..., P_n}, C )</span></pre>
<p>Uma resolução por DP precisa de uma definição recursiva deste total.</p>
<p>A base da recursão ocorre quando a capacidade é zero, ou quando não há items para escolher:</p>
<pre><span style="font-family: courier new, courier, monospace; font-size: small;">total( {},    C ) = 0</span><br /><span style="font-family: courier new, courier, monospace; font-size: small;">total( {...}, 0 ) = 0</span></pre>
<p>Para lidar com o passo da recursão vamos considerar o primeiro item sendo o subproblema a chamada recursiva ao resto dos items. Deste modo, os subproblemas vão ficando mais simples, e chegaremos às bases da recursão.</p>
<p>O primeiro caso é quando temos um item tão pesado que não cabe na capacidade actual da mochila. Aqui, simplesmente não o escolhemos:</p>
<pre><span style="font-family: courier new, courier, monospace; font-size: small;">total( {P_i, ..., P_n}, C ) = total( {P_i+1, ..., P_n}, C )   ,   se W_i &gt; C</span></pre>
<p>Nos restantes casos teremos duas opções, ou escolhemos o item actual ou não:</p>
<ul>
<li>Se escolhemos o item, a capacidade da mochila diminui de acordo com o peso deste item, e o valor total calculado do resto dos itens tem de ser somado com o valor deste item.</li>
<li>Se não escolhemos, simplesmente passamos para o próximo item, como fizemos no caso do item ser mais pesado</li>
</ul>
<p>O valor total que queremos será o maior dos resultados destas duas opções!</p>
<pre><span style="font-family: courier new, courier, monospace; font-size: small;">total( {P_i, ..., P_n}, C ) = max(  V_i + total( {P_i+1, ..., P_n}, C - W_i ), </span><br /><span style="font-family: courier new, courier, monospace; font-size: small;">                                          total( {P_i+1, ..., P_n}, C       ) )</span></pre>
<p>Vamos lá por isto em código. A versão de programação dinâmica escolhida é <em>top-down</em> (ie, começamos pelo problema original e vamos pedindo para calcular os problemas mais simples) e reflecte a estrutura recursiva da nossa solução:</p>
<pre><span style="font-family: courier new, courier, monospace; font-size: small;"> static final int UNKNOWN = -1;</span><br /><span style="font-family: courier new, courier, monospace; font-size: small;"> static int[] values, weigths;</span><br /><span style="font-family: courier new, courier, monospace; font-size: small;"> static int[][] sols;</span><br /><span style="font-family: courier new, courier, monospace; font-size: small;"> static int nProducts;</span><br /> <br /><span style="font-family: courier new, courier, monospace; font-size: small;"> static int compute_sols(int i, int capacity) {</span><br /> <br /><span style="font-family: courier new, courier, monospace; font-size: small;">   if (i==nProducts || capacity==0)</span><br /><span style="font-family: courier new, courier, monospace; font-size: small;">     return 0;</span><br /> <br /><span style="font-family: courier new, courier, monospace; font-size: small;">   if (sols[i][capacity] != UNKNOWN)</span><br /><span style="font-family: courier new, courier, monospace; font-size: small;">     return sols[i][capacity];</span><br /> <br /><span style="font-family: courier new, courier, monospace; font-size: small;">   if (weigths[i] &gt; capacity)</span><br /><span style="font-family: courier new, courier, monospace; font-size: small;">     return sols[i][capacity] = compute_sols(i+1, capacity);</span><br /> <br /><span style="font-family: courier new, courier, monospace; font-size: small;">   return sols[i][capacity] = </span><br /><span style="font-family: courier new, courier, monospace; font-size: small;">            Math.max(             compute_sols(i+1, capacity), </span><br /><span style="font-family: courier new, courier, monospace; font-size: small;">                      values[i] + compute_sols(i+1, capacity - weigths[i]) );</span><br /><span style="font-family: courier new, courier, monospace; font-size: small;"> }</span></pre>
<p>Para ler um input como o indicado no início, e calcular o resultado:</p>
<pre><span style="font-family: courier new, courier, monospace; font-size: small;">public static void main(String[] args) {</span><br /><br /><span style="font-family: courier new, courier, monospace; font-size: small;">   Scanner sc = new Scanner(System.in);</span><br /><span style="font-family: courier new, courier, monospace; font-size: small;">   int capacity = sc.nextInt();</span><br /><span style="font-family: courier new, courier, monospace; font-size: small;">   nProducts = sc.nextInt();</span><br /><br /><span style="font-family: courier new, courier, monospace; font-size: small;">   values = new int[nProducts];</span><br /><span style="font-family: courier new, courier, monospace; font-size: small;">   weigths = new int[nProducts];</span><br /><br /><span style="font-family: courier new, courier, monospace; font-size: small;">   for (int i=0; i&lt;nProducts; i++) {</span><br /><span style="font-family: courier new, courier, monospace; font-size: small;">     values[i] = sc.nextInt();</span><br /><span style="font-family: courier new, courier, monospace; font-size: small;">     weigths[i] = sc.nextInt();</span><br /><span style="font-family: courier new, courier, monospace; font-size: small;">   }</span><br /><span style="font-family: courier new, courier, monospace; font-size: small;">   sc.close();</span><br /><br /><span style="font-family: courier new, courier, monospace; font-size: small;">   sols = new int[nProducts][capacity+1];</span><br /><span style="font-family: courier new, courier, monospace; font-size: small;">   for(int i=0; i&lt;nProducts; i++) </span><br /><span style="font-family: courier new, courier, monospace; font-size: small;">     for(int j=0; j&lt;=capacity; j++)</span><br /><span style="font-family: courier new, courier, monospace; font-size: small;">       sols[i][j] = UNKNOWN;</span><br /><br /><span style="font-family: courier new, courier, monospace; font-size: small;">   System.out.printf("%d\n", compute_sols(0, capacity));</span><br /><span style="font-family: courier new, courier, monospace; font-size: small;"> }</span></pre>
<p>A abordagem <em>top-down</em> evita calcular a tabela toda, apenas calcula os elementos estritamente necessários para calcular a solução. Se imprimirmos a tabela <span style="font-family: courier new, courier, monospace; font-size: small;">sols[][]</span> com o input do exemplo obtemos o seguinte:</p>
<pre><span style="font-family: courier new, courier, monospace; font-size: small;">        capacity: 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 </span><br /><span style="font-family: courier new, courier, monospace; font-size: small;">(val:13, wgt: 5) -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 <strong><span style="color: #0000ff;">75</span></strong> </span><br /><span style="font-family: courier new, courier, monospace; font-size: small;">(val:30, wgt:10) -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 <strong><span style="color: #00ff00;">62</span></strong> -1 -1 -1 -1 <strong><span style="color: #00ff00;">74</span></strong> </span><br /><span style="font-family: courier new, courier, monospace; font-size: small;">(val:15, wgt: 6) -1 -1 -1 -1 -1 -1 -1 -1 -1 32 -1 -1 -1 -1 44 -1 -1 -1 -1 44 -1 -1 -1 -1 65 </span><br /><span style="font-family: courier new, courier, monospace; font-size: small;">(val:12, wgt: 2) -1 -1 -1 17 -1 -1 -1 -1 29 29 -1 -1 -1 29 29 -1 -1 -1 29 36 -1 -1 -1 -1 65 </span><br /><span style="font-family: courier new, courier, monospace; font-size: small;">(val:36, wgt:19) -1  5 -1 17 -1 -1 17 17 17 17 -1 17 17 17 17 -1 17 17 17 36 -1 -1 53 -1 53 </span><br /><span style="font-family: courier new, courier, monospace; font-size: small;">(val: 5, wgt: 1) -1  5 -1 17 -1 17 17 17 17 17 -1 17 17 17 17 -1 17 17 17 17 -1 -1 17 -1 17 </span><br /><span style="font-family: courier new, courier, monospace; font-size: small;">(val:12, wgt: 2) -1  0 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 -1 12 12 12 12</span></pre>
<p>Os valores -1 são os valores por calcular. Podemos observar que cerca de metade da tabela não foi calculada.</p>
<p>Seria possível construir esta tabela, numa abordagem <em>bottom-up</em>, a partir da solução recursiva. Por exemplo, o elemento a azul foi calculado a partir dos elementos a verde. Confirme o porquê na definição recursiva que usa o máximo.</p>
<p>Se o quiséssemos fazer, dever-se-ia começar por preencher a primeira linha ou a última linha desta tabela?</p>
<p>Experimentem esta técnica do Knapsack resolvendo o <a href="https://uva.onlinejudge.org/external/101/p10130.pdf">UVa 10130</a>.</p>
<hr />
<p>Em resumo, a programação dinâmica aplica‑se a problemas com as seguintes características:</p>
<ul>
<li>O problema pode ser decomposto em subproblemas;</li>
<li>Os subproblemas partilham subsubproblemas; e</li>
<li>A solução óptima pode ser composta a partir das sub-soluções encontradas (nota: quando há várias opções de solução, estas sub-soluções devem ser <em>sub-soluções óptimas</em>,<em> i.e., </em>as melhores possíveis de acordo com o critério dado).</li>
</ul>
<p>O primeiro ponto refere que deve ser possível definir recursivamente o problema.</p>
<p>O segundo ponto restringe‑se aos problemas onde a definição recursiva produz um algoritmo com complexidade muito elevada, como a exponencial.</p>
<p>O terceiro e último ponto descreve um ingrediente necessário para que a programação dinâmica funcione: a capacidade de construir um conjunto de soluções do mais simples para o mais complexo <i>utilizando somente as sub-soluções óptimas</i>. Caso contrário será necessário explorar todas as possibilidades não óptimas, o que resulta num algoritmo de complexidade excessiva.</p>
<p></p>
<p></p>
<p></p></div></div><div class="modified">Last modified: Friday, 27 March 2020, 9:50 AM</div></div>

</body>
</html>