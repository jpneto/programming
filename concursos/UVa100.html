<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=yes">
  <meta name="description" content="dynamic programming">
  <title>UVa 100: 3n+1</title>
</head>

<body>

<h1 style="text-align: center;">UVa 100: 3n+1</h1>
<center><span style="font-size: small;"><em>João Pedro Neto</em></span></center>

<p>Leia o <a href="https://uva.onlinejudge.org/external/1/100.pdf">enunciado</a> antes de continuarmos.</p>
<p>A primeira versão que li deste problema tinha como limite máximo uma dimensão de 10000. Vamos considerar inicialmente que este era o limite.</p>
<p>Se eu pretender saber qual é o ciclo máximo (maxCycle) entre i e j, preciso conhecer todas as dimensões dos ciclos entre i e j incluídos. Por exemplo, o maxCycle(1,1000) precisa calcular-se 1001 ciclos, de 1 a 1000. A seguinte função calcula a dimensão de um ciclo:</p>
<pre style="margin-left: 30px;"><span style="font-size: small;">static int cycleLength(int n) {</span><br /><span style="font-size: small;">  int result = 1;</span><br /><br /><span style="font-size: small;">  while (n!=1) {</span><br /><span style="font-size: small;">    n = n%2==0 ? n/2 : 3*n+1;</span><br /><span style="font-size: small;">    result++;</span><br /><span style="font-size: small;">  }</span><br /><span style="font-size: small;">  return result;</span><br /><span style="font-size: small;">}</span></pre>
<p>Isto pode fazer-se com rapidez, mas se a seguir pedir-se <span style="font-family: 'courier new', courier, monospace;">maxCycle(100,500)</span> será escusado estar a repetir cálculos que já foram realizados.</p>
<p>Se quisermos abordar do ponto de vista da <a class="autolink" title="Programação Dinâmica" href="https://moodle.ciencias.ulisboa.pt/mod/page/view.php?id=113896">programação dinâmica</a> (DP) temos de decompor o problema em subproblemas, e verificar se os subproblemas partilham sub-subproblemas.</p>
<p>Ora, uma abordagem recursiva diz-nos o seguinte: para calcular <span style="font-family: 'courier new', courier, monospace;">maxCycle(1,1000)</span> se eu souber <span style="font-family: 'courier new', courier, monospace;">maxCycle(1,500)</span> e <span style="font-family: 'courier new', courier, monospace;">maxCycle(501,1000)</span>, eu já sei a solução (é o maior dos dois).</p>
<p>Nesta abordagem, porém, não há partilha de sub-subproblemas. Isto não significa que não se possa pensar numa solução com esta estratégia, mas estamos à procura de uma solução 100% DP.</p>
<p>Uma outra alternativa de formulação é dizer que <span style="font-family: 'courier new', courier, monospace;">maxCycle(1,1000)</span> é o máximo entre <span style="font-family: 'courier new', courier, monospace;">maxCycle(2,1000)</span> e <span style="font-family: 'courier new', courier, monospace;">maxCycle(1,999)</span>. Estes dois subproblemas partilham sub-subproblemas (por exemplo, <span style="font-family: 'courier new', courier, monospace;">maxCycle(2,999)</span>).</p>
<p>Para concretizar esta solução precisamos de uma matriz triangular para guardar todas as combinações de <span style="font-family: 'courier new', courier, monospace;">maxCycle(i,j)</span> entre <span style="font-family: 'courier new', courier, monospace;">1 &lt; i &lt;= j &lt; 10000</span>.</p>
<pre style="margin-left: 30px;"><span style="font-size: small;">static final int SIZE = 10000, UNKNOWN = 0;</span><br /> <br /><span style="font-size: small;"> static int[][] computeMatrix() {</span><br /><span style="font-size: small;">    int[][] sols = new int[SIZE+1][];</span><br /> <br /><span style="font-size: small;">    // make a triangular matrix, since maxCycle[i][j] is valid only for i&lt;=j</span><br /><span style="font-size: small;">    // notice that rows and cols were flipped, since we made a lower triangular matrix</span><br /><span style="font-size: small;">    for(int i=1; i&lt;=SIZE; i++)</span><br /><span style="font-size: small;">       sols[i] = new int[i+1]; // init to zero, ie, UNKNOWN</span><br /><br /><span style="font-size: small;">    computeMaxCycles(SIZE, 1, sols);    // compute max cycle lengths</span><br /><span style="font-size: small;">    return sols;</span><br /><span style="font-size: small;"> }</span></pre>
<p>A função <span style="font-family: 'courier new', courier, monospace;">computeMaxCycles</span> (que vai preencher a matriz) é invocada com pedido máximo de 1 a 10000. De reparar que damos o <span style="font-family: 'courier new', courier, monospace;">j</span> no 1º argumento, dada a forma como a matriz é construída (os <span style="font-family: 'courier new', courier, monospace;">j</span>'s são as <a class="autolink" title="Linhas" href="https://moodle.ciencias.ulisboa.pt/mod/page/view.php?id=113909">linhas</a> da matriz).</p>
<pre style="margin-left: 30px;"><span style="font-size: small;">static void computeMaxCycles(int j, int i, int[][] sols) {</span><br /><br /><span style="font-size: small;">    if (i==j &amp;&amp; sols[j][i] == UNKNOWN)   // base of recursion</span><br /><span style="font-size: small;">      sols[j][i] = cycleLength(i);</span><br /><span style="font-size: small;">    else {</span><br /><br /><span style="font-size: small;">      if (sols[j-1][i] == UNKNOWN)</span><br /><span style="font-size: small;">        computeMaxCycles(j-1, i, sols);</span><br /><br /><span style="font-size: small;">      if (sols[j][i+1] == UNKNOWN)</span><br /><span style="font-size: small;">        computeMaxCycles(j, i+1, sols);</span><br /><br /><span style="font-size: small;">      sols[j][i] = Math.max(sols[j-1][i], sols[j][i+1]);</span><br /><span style="font-size: small;">  }</span><br /><span style="font-size: small;">}</span></pre>
<p>Quando este processamento termina, obtemos uma matriz com todas as soluções <span style="font-family: 'courier new', courier, monospace;">maxCycle(i,j)</span>. O início dela (não esquecer: as <a class="autolink" title="Linhas" href="https://moodle.ciencias.ulisboa.pt/mod/page/view.php?id=113909">linhas</a> são os <span style="font-family: 'courier new', courier, monospace;">j</span>'s):</p>
<pre style="margin-left: 30px;"><span style="font-size: medium;"> 1</span><br /><span style="font-size: medium;"> 2,  2</span><br /><span style="font-size: medium;"> 8,  8,  8</span><br /><span style="font-size: medium;"> 8,  8,  8,  3</span><br /><span style="font-size: medium;"> 8,  8,  8,  6,  6</span><br /><span style="font-size: medium;"> 9,  9,  9,  9,  9,  9</span><br /><span style="font-size: medium;">17, 17, 17, 17, 17, 17, 17</span><br /><span style="font-size: medium;">17, 17, 17, 17, 17, 17, 17, 4</span><br /><span style="font-size: medium;">20, 20, 20, 20, 20, 20, 20, 20, 20</span><br /><span style="font-size: medium;">...</span></pre>
<p>Qual é o problema desta solução? Se executarmos para o limite de 10000 obtemos esta mensagem:</p>
<pre style="margin-left: 30px;"><span style="font-size: small;">Exception in thread "main" java.lang.StackOverflowError</span></pre>
<p>As invocações recursivas são demasiado profundas!</p>
<p>Quando temos este problema é altura de procurar uma solução iterativa!</p>
<p>Se olharmos para a linha</p>
<pre style="margin-left: 30px;"><span style="font-size: small;">sols[j][i] = Math.max(sols[j-1][i], sols[j][i+1])</span></pre>
<p>reparamos que um dado valor da matriz acima é calculado pelo máximo dos valores que lhe estão acima e à direita. Isto dá-nos uma pista de como fazer uma função iterativa: começar a preencher a matrix linha a linha, de cima para baixo, e em cada linha começar pela direita, ie, pelo último elemento (que é a diagonal com os valores <span style="font-family: 'courier new', courier, monospace;">cycleMax(j,j)</span>).</p>
<pre style="margin-left: 30px;"><span style="font-size: small;">static void computeMaxCyclesIter(int[][] sols) {</span><br /><span style="font-size: small;">  // compute cycle length from naturals 1 to SIZE </span><br /><span style="font-size: small;">  for(int i=1; i&lt;=SIZE; i++)</span><br /><span style="font-size: small;">    sols[i][i] = cycleLength(i);</span><br /><br /><span style="font-size: small;">  // compute remaining solutions</span><br /><span style="font-size: small;">  for(int j=2; j&lt;=SIZE; j++) // for each row, starting 2nd:</span><br /><span style="font-size: small;">    for (int i=j-1; i&gt;0; i--)</span><br /><span style="font-size: small;">      sols[j][i] = Math.max(sols[j-1][i], sols[j][i+1]); </span><br /><span style="font-size: small;"> }</span></pre>
<p>E agora já conseguimos calcular a matriz correctamente sem erros de <em>runtime</em>.</p>
<hr />
<p>Mas...</p>
<p>O problema no site da UVa tem limite 1000000 (!!).</p>
<p>Esta segunda solução também não serve, dado que uma matriz triangular destas dimensões teria meio trilião de valores, o que rebenta com a memória disponível...</p>
<p>Para resolver este caso temos de largar a solução DP e tentar outra coisa (bem, isto é um tutorial de como modelar problemas com <a class="autolink" title="Programação Dinâmica" href="https://moodle.ciencias.ulisboa.pt/mod/page/view.php?id=113896">programação dinâmica</a> mas, já que apresentámos o problema, vamos resolvê-lo).</p>
<p>A solução sugerida a seguir é para cada par de valores <span style="font-family: 'courier new', courier, monospace;">i, j</span>, percorrer todos os valores intermédios e calcular os seus ciclos.</p>
<p>Mas para ser mais rápido usamos memorização, a tal técnica também usada na DP que guarda as soluções encontradas até então. Desta forma, há medida que são calculados os <span style="font-family: 'courier new', courier, monospace;">cycleMax(i,j)</span>, o vector de soluções vai ficando preenchido e o tempo de cálculo dos restantes valores fica progressivamente mais rápido.</p>
<p>Notem que temos memória para criar um vector de um milhão de posições (a matrix é que não dava).</p>
<p>Um exemplo:</p>
<pre style="margin-left: 30px;"><span style="font-size: small;"> static final int SIZE = 1000000, UNKNOWN = 0;</span><br /><span style="font-size: small;"> static int[] sols;</span><br /> <br /><span style="font-size: small;"> static int computeCycle(int k) {</span><br /> <br /><span style="font-size: small;">   if (k &lt;= SIZE &amp;&amp; sols[k] != UNKNOWN)</span><br /><span style="font-size: small;">     return sols[k];</span><br /> <br /><span style="font-size: small;">   int result = 1 + (k%2==0 ? computeCycle(k/2) : computeCycle(3*k+1));</span><br /> <br /><span style="font-size: small;">   if (k &lt;= SIZE) // only keep values &lt;= SIZE</span><br /><span style="font-size: small;">     sols[k] = result;</span><br /> <br /><span style="font-size: small;">   return result;</span><br /><span style="font-size: small;"> }</span></pre>
<p>No <span style="font-family: 'courier new', courier, monospace;">main()</span> fazemos as inicializações e respondemos a cada um dos pares de input:</p>
<pre style="margin-left: 30px;"><span style="font-size: small;">public static void main(String[] args) {</span><br /><span style="font-size: small;">  sols    = new int[SIZE+1];</span><br /><span style="font-size: small;">  sols[1] = 1;</span><br /><br /><span style="font-size: small;">  Scanner sc = new Scanner(System.in);</span><br /><br /><span style="font-size: small;">  while (sc.hasNextInt()) {</span><br /><span style="font-size: small;">    int i = sc.nextInt(), </span><br /><span style="font-size: small;">        j = sc.nextInt();</span><br />   <br /><span style="font-size: small;">    int from = Math.min(i, j), </span><br /><span style="font-size: small;">        to = Math.max(i, j),</span><br /><br /><span style="font-size: small;">    result = 0;</span><br /><span style="font-size: small;">    for(int k=from; k&lt;=to; k++) </span><br /><span style="font-size: small;">       result = Math.max(result, computeCycle(k));</span><br /><br /><span style="font-size: small;">    System.out.println(i + " " + j + " " + result); </span><br /><span style="font-size: small;">   }</span><br /><br /><span style="font-size: small;">   sc.close();</span><br /><span style="font-size: small;"> }</span></pre>
<p>Referência: <a href="http://www.algorithmist.com/index.php/UVa_100">http://www.algorithmist.com/index.php/UVa_100</a></p></div></div><div class="modified">Last modified: Thursday, 13 October 2016, 9:04 AM</div></div>

</body>
</html>